# 算法与数据结构

<a name="uEaSp"></a>

## 时间复杂度

- 一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。
- 时间复杂度为一个算法流程中，常数操作数量的一个指标。常用 O(读作 big O)来表示。
- 在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果为 f(N)，那 么时间复杂度为 O(f(N))。

```javascript
// O(n)
funtion demo1 () {
  for (i=0;i<arr.length;i++){
    console.log(arr[i])
  }
}
//	此时console.log为常数操作，执行了n次，所以复杂度为O(n)

// O(n^2)
funtion demo1 () {
  for (i=0;i<arr.length;i++){
    for (j=i+1;j<arr.length;j++){
    	console.log(arr[j])
    }
  }
}
// 此时常数操作次数为等差数列，n+(n-1)+(n-2)+……+1，总次数为n^2/2+n/2，取最高阶的数量，所以时间复杂度为O(n^2)
```

<a name="rKZNk"></a>

## 基本排序

<a name="ZkDTq"></a>

#### 选择排序

- 时间复杂度 O(n^2)
- 根据排序不同情况差别大
  - 正序 O(n)
  - 倒序 O(n^2)
- 基本过程
  - 从左开始处理，每次遍历将右侧最小值找出，然后放在左边
  - 下次再遍历的时候指针向右侧移动，再找右侧最小值

```javascript
function selectSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let minIndex = i;
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[j] < arr[minIndex]) minIndex = j;
    }
    if (minIndex !== i) {
      [arr[minIndex], arr[i]] = [arr[i], arr[minIndex]];
    }
  }
  return arr;
}
```

<a name="XWT4g"></a>

#### 冒泡排序

- 时间复杂度 O(n^2)
- 基本过程
  - 优先处理最大值，逐一比较交换顺序，直到将最大值置换到最右侧
  - 指针末端右移，在重新进行遍历

```javascript
function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  // 返回数组
  return arr;
}
```

<a name="AaPDd"></a>

#### 插入排序

- 时间复杂度 O(n^2)
- 基本过程
  - 从第一个元素开始，该元素可以认为已经被排序
  - 取出下一个元素，在已经排序的元素序列中从后向前扫描
  - 如果该元素（已排序）大于新元素，将新元素插入到该元素（已排序）前面

```javascript
function insertionSort(arr) {
  for (let i = 0; i < arr.length; i++) {
    let j = i;
    while (arr[j] > arr[j + 1] && j >= 0) {
      [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      j--;
    }
  }
  return arr;
}

function insertSort(arr) {
  // 缓存数组长度
  const len = arr.length;
  // temp 用来保存当前需要插入的元素
  let temp;
  // i用于标识每次被插入的元素的索引
  for (let i = 1; i < len; i++) {
    // j用于帮助 temp 寻找自己应该有的定位
    let j = i;
    temp = arr[i];
    // 判断 j 前面一个元素是否比 temp 大
    while (j > 0 && arr[j - 1] > temp) {
      // 如果是，则将 j 前面的一个元素后移一位，为 temp 让出位置
      arr[j] = arr[j - 1];
      j--;
    }
    // 循环让位，最后得到的 j 就是 temp 的正确索引
    arr[j] = temp;
  }
  return arr;
}
```

<a name="z7Alt"></a>

#### 并归排序

- 时间复杂度，套用 master 公式
  - T(N) = a\*T(N/b) + O(N^d)
  - T(N) = 2\*T(N/2) + O(N)
  - log(b,a) = d -> 复杂度为 O(N^d \* logN)
  - O(NlogN)
- 基本流程
  - 先用二分法递归将数组分成两段
  - 从底向上递归过程中执行 merge 过程
  - 依次从左右两段循环，将左右两段最小值取出放入新数组中，有剩下的将依次返回新数组后面
  - 最后重新组成合并后的有序数组
  - 注：当递归到最后，数组最长默认只有两个元素，可以视为有序数组。

```javascript
function mergeSort(testArr) {
  const len = testArr.length;
  if (len < 2) {
    return testArr;
  }
  const middle = Math.floor(len / 2);
  let left = testArr.slice(0, middle);
  let right = testArr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right) {
  let result = [];
  while (left.length && right.length) {
    left[0] < right[0] ? result.push(left.shift()) : result.push(right.shift());
  }

  while (left.length) {
    result.push(left.shift());
  }

  while (right.length) {
    result.push(right.shift());
  }
  return result;
}

function mergeSort(arr) {
  const len = arr.length;
  // 处理边界情况
  if (len <= 1) {
    return arr;
  }
  // 计算分割点
  const mid = Math.floor(len / 2);
  // 递归分割左子数组，然后合并为有序数组
  const leftArr = mergeSort(arr.slice(0, mid));
  // 递归分割右子数组，然后合并为有序数组
  const rightArr = mergeSort(arr.slice(mid, len));
  // 合并左右两个有序数组
  arr = mergeArr(leftArr, rightArr);
  // 返回合并后的结果
  return arr;
}

function mergeArr(arr1, arr2) {
  // 初始化两个指针，分别指向 arr1 和 arr2
  let i = 0,
    j = 0;
  // 初始化结果数组
  const res = [];
  // 缓存arr1的长度
  const len1 = arr1.length;
  // 缓存arr2的长度
  const len2 = arr2.length;
  // 合并两个子数组
  while (i < len1 && j < len2) {
    if (arr1[i] < arr2[j]) {
      res.push(arr1[i]);
      i++;
    } else {
      res.push(arr2[j]);
      j++;
    }
  }
  // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分
  if (i < len1) {
    return res.concat(arr1.slice(i));
  } else {
    return res.concat(arr2.slice(j));
  }
}
```

<a name="Taqv2"></a>

#### 快速排序

- 时间复杂度
  - 最佳情况：T(n) = O(nlogn) [恰好去到中间值作为标准值]
  - 最差情况：T(n) = O(n^2) [当数组刚好是正序时，每次快排只解决一个数组，遍历次数为等差数列]
  - 平均情况：T(n) = O(nlogn) [随机取一个元素作为标准值]
- 基本流程[平均情况]
  - 在数组中随机取一个元素放在数组最后作为标准值
  - 经过 patition 过程，使得数组按小于等于大于标准值顺序排列
    - 小于标准值---左侧指针第一二位对换，左侧指针右移动
    - 大于标准值---左侧指针与右侧指针元素对换，右侧指针左移动
    - 等于标准值---左侧指针右移，不做对换
    - patition 完成后，与标准值相同的在中间，小于区域在最左边，大于区域在最右边
    - 返回中间区域的位置
  - 将中间区域去处，大于和小于区域再次进行快排
  - 不断递归，当 l<r 时作为退出值

```javascript
function quickSort(testArr, l, r) {
  if (l < r) {
    swap(testArr, l + Math.floor(Math.random() * (r - l + 1)), r);
    const p = patition(testArr, l, r);
    quickSort(testArr, l, p[0] - 1);
    quickSort(testArr, p[1] + 1, r);
  }
  return testArr;
}

function patition(testArr, l, r) {
  let less = l - 1;
  let more = r - 1; //右指针在倒数第二位置
  while (l < more) {
    if (testArr[l] < testArr[r]) {
      ++less; //左区间扩大
      swap(testArr, less, l);
      l++; //指针右移
    } else if (testArr[l] > testArr[r]) {
      swap(testArr, more, l);
      more--; //右区间左扩大，指针不动，将对换的值用于下次比较
    } else {
      l++;
    }
  }
  swap(testArr, more, r);
  return [less + 1, more];
}

// js 极简版
function quickSort(arr) {
  if (arr.length < 2) {
    return arr;
  }
  const cur = arr[arr.length - 1];
  const left = arr.filter((v, i) => v <= cur && i !== arr.length - 1);
  const right = arr.filter((v) => v > cur);
  return [...quickSort(left), cur, ...quickSort(right)];
}
```

- 思路二
  - 随机选取数组中的一个元素作为基准，遍历数组中左右两个指针
    - 左指针小于基准值右移
    - 右指针大于基准值左移
    - 两指针都停止时候，说明左指针大于基准值，右指针小于基准值，交换左右两指针都值继续移动
    - 直到左指针位置在右指针后面
  - 每次都保证了基准值位于大小值的中间位置，但是此时左右区间并不是有序
  - 再继续将基准值的左右区间进行递归操作，直到分割后剩下最后两个元素，排序后必然有序
  - 与并归排序不同，并归是从底层开始向上排序合并；快排是从上就是慢慢排序，最终到的底层排序后就是实现了排序

```javascript
// 快速排序入口
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 定义递归边界，若数组只有一个元素，则没有排序必要
  if (arr.length > 1) {
    // lineIndex表示下一次划分左右子数组的索引位
    const lineIndex = partition(arr, left, right);
    // 如果左边子数组的长度不小于1，则递归快排这个子数组
    if (left < lineIndex - 1) {
      // 左子数组以 lineIndex-1 为右边界
      quickSort(arr, left, lineIndex - 1);
    }
    // 如果右边子数组的长度不小于1，则递归快排这个子数组
    if (lineIndex < right) {
      // 右子数组以 lineIndex 为左边界
      quickSort(arr, lineIndex, right);
    }
  }
  return arr;
}
// 以基准值为轴心，划分左右子数组的过程
function partition(arr, left, right) {
  // 基准值默认取中间位置的元素
  let pivotValue = arr[Math.floor(left + (right - left) / 2)];
  // 初始化左右指针
  let i = left;
  let j = right;
  // 当左右指针不越界时，循环执行以下逻辑
  while (i <= j) {
    // 左指针所指元素若小于基准值，则右移左指针
    while (arr[i] < pivotValue) {
      i++;
    }
    // 右指针所指元素大于基准值，则左移右指针
    while (arr[j] > pivotValue) {
      j--;
    }

    // 若i<=j，则意味着基准值左边存在较大元素或右边存在较小元素，交换两个元素确保左右两侧有序
    if (i <= j) {
      swap(arr, i, j);
      i++;
      j--;
    }
  }
  // 返回左指针索引作为下一次划分左右子数组的依据
  return i;
}

// 快速排序中使用 swap 的地方比较多，我们提取成一个独立的函数
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}
```

<a name="yGAve"></a>

#### 堆排序

- 时间复杂度：T(n)=O(nlogn)
- 堆基本概念
  - 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
  - 如果每棵子树的最大值都在顶部就是大根堆
  - 如果每棵子树的最小值都在顶部就是小根堆
  - 基本操作方式
    - heapInsert：向上更新树结构
    - heapify：向下更新树结构
    - 左侧子分支序号：index\*2+1
    - 右侧子分支序号：index\*2+2
    - 父分支序号：Math.floor((index-1)/2)
- 基本流程
  - 数组转化成大根堆
  - 堆最顶一个与堆最后一个对换
  - 堆长度减一，执行 heapify 重新整理成大根堆
  - 直到堆长度为 0 时退出循环

```javascript
function heapSort(testArr) {
  // 复杂度 O(nlogn)
  // for(let i =0;i<testArr.length;i++){ // O(n)
  //     heapInsert(testArr,i)   // O(logn)
  // }

  // 复杂度 O(n),由于最后一排无子节点，减少复杂度
  for (let i = testArr.length - 1; i >= 0; i--) {
    heapify(testArr, i, testArr.length);
  }

  // 将大根堆定换到最后，堆长度减少，再重新经过heapify过程形成新的堆顶
  // 为了将数组从小到大排序
  let size = testArr.length;
  swap(testArr, 0, --size);
  while (size > 0) {
    // O(n)
    heapify(testArr, 0, size); // O(logn)
    swap(testArr, 0, --size);
  }

  return testArr;
}

function heapify(testArr, index, size) {
  // 获取当前index的左侧子节点序号
  let left = index * 2 + 1;
  while (left < size) {
    // 比较左右子节点大小，取最大节点的序号
    let largest =
      left + 1 < size && testArr[left + 1] > testArr[left] ? left + 1 : left;
    // 最大子节点与当前index对比
    largest = testArr[largest] > testArr[index] ? largest : index;
    // 当最大值为当前index，则说明该父节点的已经成为大根堆退出循环
    if (largest === index) break;
    // 交换父子位置
    swap(testArr, largest, index);
    // 将当前节点序号换成对换堆子节点序号
    index = largest;
    left = index * 2 + 1;
  }
}

function heapInsert(testArr, index) {
  // 向上对比父节点的大小
  // 若大于则对换位置
  // 小于或等于退出循环
  while (testArr[index] > testArr[Math.floor((index - 1) / 2)]) {
    swap(testArr, index, Math.floor((index - 1) / 2));
    index = Math.floor((index - 1) / 2);
  }
}
```

<a name="LCaqp"></a>

#### 计数排序

- 时间复杂度：T(n) = O(n+k)，k 为数组最大值
- 基本流程
  - 开辟一个空间 bucket 存储数组中数字出现的次数，bucket 长度取决于数组最大值
  - 遍历数组，将数组的值作为 bucket 的 index 序号，并记录该值出现次数
  - 根据 bucket 依次将元素吐出

```javascript
function countSort(testArr) {
  let bucket = [];
  for (let i = 0; i < testArr.length; i++) {
    bucket[testArr[i]] ? bucket[testArr[i]]++ : (bucket[testArr[i]] = 1);
  }
  let index = 0;
  for (let i = 0; i < bucket.length; i++) {
    while (bucket[i]-- > 0) {
      testArr[index++] = i;
    }
  }

  return testArr;
}
```

<a name="UljSZ"></a>

#### 桶排序

- 时间复杂度
  - 最佳情况：T(n) = O(n+k)
  - 最差情况：T(n) = O(n+k)
  - 平均情况：T(n) = O(n2)
  - 桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。
- 基本过程
  - 设置一个定量的数组当作空桶；
  - 遍历输入数据，并且把数据一个一个放到对应的桶里去；
  - 对每个不是空的桶进行排序；
  - 从不是空的桶里把排好序的数据拼接起来。

```javascript
function bucketSort(array, num) {
  if (array.length <= 1) {
    return array;
  }
  var len = array.length;
  buckets = [];
  result = [];
  min = max = array[0];
  regex = "/^[1-9]+[0-9]*$/";
  space = 0;
  n = 0;
  // 桶数量
  num = num || (num > 1 && regex.test(num) ? num : 10);
  console.time("桶排序耗时");
  for (var i = 1; i < len; i++) {
    min = min <= array[i] ? min : array[i];
    max = max >= array[i] ? max : array[i];
  }
  space = (max - min + 1) / num;
  for (var j = 0; j < len; j++) {
    var index = Math.floor((array[j] - min) / space);
    if (buckets[index]) {
      //  非空桶，插入排序
      var k = buckets[index].length - 1;
      while (k >= 0 && buckets[index][k] > array[j]) {
        buckets[index][k + 1] = buckets[index][k];
        k--;
      }
      buckets[index][k + 1] = array[j];
    } else {
      //空桶，初始化
      buckets[index] = [];
      buckets[index].push(array[j]);
    }
  }
  while (n < num) {
    result = result.concat(buckets[n]);
    n++;
  }
  return result;
}
```

<a name="QC5Rw"></a>

#### 基数排序

- 时间复杂度：T(n) = O(n \* k)
- 基本流程
  - 从低位入十进制的十个桶
  - 依次出桶排序
  - 再次用更高位进桶
  - 直到达到最高位

```javascript
//	digit 位数长度
function radixSort(testArr, begin, end, digit) {
  let radix = 10;
  let i = 0,
    j = 0;
  let bucket = [];

  for (let d = 1; d <= digit; d++) {
    // 创建当前位数对应的十个桶
    let count = new Array(10).fill(0);
    // 根据当前对应的序号进行累计
    for (i = begin; i <= end; i++) {
      j = getDigit(testArr[i], d);
      count[j]++;
    }
    // 桶序号存储小于等于桶序号的数
    for (i = 1; i < radix; i++) {
      count[i] = count[i] + count[i - 1];
    }
    // 此时累计值对应的是排序的位置
    // 出一个桶序号减一
    for (i = end; i >= begin; i--) {
      j = getDigit(testArr[i], d);
      bucket[count[j] - 1] = testArr[i];
      count[j]--;
    }
    for (i = begin, j = 0; i <= end; i++, j++) {
      testArr[i] = bucket[j];
    }
  }
}

// 求当前位数对应的桶序号
function getDigit(x, d) {
  return Math.floor(x / Math.pow(10, d - 1)) % 10;
}
```

<a name="ivY8W"></a>

#### 总结<br /><br />

|          | 时间复杂度 | 空间复杂度 | 稳定性 |
| -------- | ---------- | ---------- | ------ |
| 选择排序 | O(n^2)     | O(1)       | 无     |
| 冒泡排序 | O(n^2)     | O(1)       | 有     |
| 插入排序 | O(n^2)     | O(1)       | 有     |
| 并归排序 | O(nlogn)   | O(n)       | 有     |
| 快速排序 | O(nlogn)   | O(logn)    | 无     |
| 堆排序   | O(nlogn)   | O(1)       | 无     |

- 稳定性：及时比较的值相同，也会保持原数组的顺序
  <a name="tPPZi"></a>

#### 附加内容

<a name="Mw4fI"></a>

###### 异或运算

1)0^N == N N^N == 0<br />2)异或运算满足交换律和结合率<br />3)不用额外变量交换两个数

```javascript
//	原理将整数化为2进制位运算
a = [1, 0, 1, 0, 0, 1];
b = [0, 0, 0, 1, 0, 1];
0 = [0, 0, 0, 0, 0, 0];

a ^ 0 = [1, 0, 0, 0, 1];
a ^ a = [0, 0, 0, 0, 0] = 0;

a ^ b = [1, 0, 1, 1, 0, 0];
a ^ b ^ b = [1, 0, 1, 0, 0, 1] = a;

//	arr第i位和第j位进行对换,减少一个临时变量空间存储
arr[i] = arr[i] ^ arr[j];
arr[j] = arr[i] ^ arr[j]; // arr[i]^arr[j]^arr[j]=arr[i]^0=arr[i]
arr[i] = arr[i] ^ arr[i]; // arr[j]^arr[i]^arr[i]=arr[i]^0=arr[j]
```

<a name="YD2YE"></a>

###### 二分法

- 将数组对半分开，左右区间进行判断取舍，再进行对半分割
- 复杂度为 log2(N)
- 在一个有序数组中，找某个数是否存在

```javascript
function existNum(sortedArr, num) {
  if (sortedArr == null || sortedArr.length == 0) {
    return false;
  }
  let L = 0;
  let R = sortedArr.length - 1;
  let mid = 0;
  while (L < R) {
    mid = L + ((R - L) >> 1); //往下保留取终点
    if (sortedArr[mid] == num) {
      return true;
    } else if (sortedArr[mid] > num) {
      R = mid - 1;
    } else {
      L = mid + 1;
    }
  }
  return sortedArr[L] == num;
}
```

<a name="MeoI6"></a>

###### 递归

- 时间复杂度的估算，master 公式计算 T(N) = a\*T(N/b) + O(N^d)
  - log(b,a) > d -> 复杂度为 O(N^log(b,a))
  - log(b,a) = d -> 复杂度为 O(N^d \* logN)
  - log(b,a) < d -> 复杂度为 O(N^d)
- 递归方法找一个数组中的最大值

```javascript
// 将数组不断二分到最小单位[x]、[l,r]
// 使用Math.max对比两个数
// 向上返回当前部分的最大值

function getMax(arr) {
  return process(arr, 0, arr.length - 1);
}

function process(arr, L, R) {
  if (L == R) {
    return arr[L];
  }
  let mid = L + ((R - L) >> 1);
  let leftMax = process(arr, L, mid); //调用2/n次
  let rightMax = process(arr, mid + 1, R); //调用2/n次
  return Math.max(leftMax, rightMax); // 常用单词操作
}
// a=2;process递归方法调用了两次
// b=2;process调用2/n次
// d=0;常用单词操作
// T(N) = 2*T(N/2) + O(1)
// log(2,2)=1
// 复杂度O(N^log(b,a))=0(N^log(2,2))=0(N)
```

<a name="hrNZ7"></a>

###### 哈希表

- 哈希表在使用层面上可以理解为一种集合结构
- 如果只有 key，没有伴随数据 value，可以使用 Set 结构
- 如果既有 key，又有伴随数据 value，可以使用 Map 结构
- 有无伴随数据，是 Map 和 Set 唯一的区别，底层的实际结构是一回事
- 使用哈希表增、删、改和查的操作，可以认为时间复杂度为 O(1)，但是常数时间比较大
- 放入哈希表的东西，如果是基础类型，内部按值传递，内存占用就是这个东西的大小
- 放入哈希表的东西，如果不是基础类型，内部按引用传递，内存占用是这个东西内存地址的大小
  <a name="jE3tN"></a>
  ######## Map

- new Map() —— 创建 map。
- map.set(key, value) —— 根据键存储值。
- map.get(key) —— 根据键来返回值，如果 map 中不存在对应的 key，则返回 undefined。
- map.has(key) —— 如果 key 存在则返回 true，否则返回 false。
- map.delete(key) —— 删除指定键的值。
- map.clear() —— 清空 map。
- map.size —— 返回当前元素个数。
  <a name="FnZXr"></a>
  ######## Set

- new Set(iterable) —— 创建一个 set，如果提供了一个 iterable 对象（通常是数组），将会从数组里面复制值到 set 中。
- set.add(value) —— 添加一个值，返回 set 本身
- set.delete(value) —— 删除值，如果 value 在这个方法调用的时候存在则返回 true ，否则返回 false。
- set.has(value) —— 如果 value 在 set 中，返回 true，否则返回 false。
- set.clear() —— 清空 set。
- set.size —— 返回元素个数。
  <a name="zwDQW"></a>

## 链表

<a name="jOhEN"></a>

#### 形式

单链表

```javascript
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}
```

双链表

```javascript
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
    this.prev = null;
  }
}
```

<a name="iuouc"></a>

#### 常见应用

<a name="uvp7s"></a>

###### 删除问题

- 正常的删除后一个节点，只需要修改 next 只想，跳过删除的节点
- 当要有删除前置节点操作会存在前置节点不存在情况，此时需要借助 dummy 结点，在链结构前面添加一个 dummy 空节点
  <a name="h8vLc"></a>

###### 快慢指针

- 由于链表不能直接返回总长度，可以利用快慢指针满足寻找条件，减少遍历
  <a name="e1D54"></a>

###### 链表反转

![](https://cdn.nlark.com/yuque/0/2023/png/1350314/1672901692182-37c5c4f2-ab57-46cd-98d6-d453595351af.png##averageHue=%23f9f9f9&crop=0&crop=0&crop=1&crop=1&from=url&id=EEvic&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=1254&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/png/1350314/1672901705514-76354e3a-1e4d-45b1-af86-dbb6a7bab1fb.png##averageHue=%23f9f8f8&crop=0&crop=0&crop=1&crop=1&from=url&id=gR4q4&margin=%5Bobject%20Object%5D&originHeight=466&originWidth=1276&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)<br />![](https://cdn.nlark.com/yuque/0/2023/png/1350314/1672901714676-bde5dedf-7e8a-4d22-afe7-cc30dabef067.png##averageHue=%23f9f9f9&crop=0&crop=0&crop=1&crop=1&from=url&id=C6aI1&margin=%5Bobject%20Object%5D&originHeight=524&originWidth=1142&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=)

- 先把 cur 的 next 保存起来
- cur 的 next 指向 pre，实现 cur 节点反转，此时会与之前的 next 脱离
- pre 改为 cur
- 反转后将之前保存的 next 改成 cur
- 下个轮巡，将 cur 的 next 指向 pre，此时的 pre 就是上一轮反正后脱离的节点，使之又连接起来了

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const reverseList = function (head) {
  // 初始化前驱结点为 null
  let pre = null;
  // 初始化目标结点为头结点
  let cur = head;
  // 只要目标结点不为 null，遍历就得继续
  while (cur !== null) {
    // 记录一下 next 结点
    let next = cur.next;
    // 反转指针
    cur.next = pre;
    // pre 往前走一步
    pre = cur;
    // cur往前走一步
    cur = next;
  }
  // 反转结束后，pre 就会变成新链表的头结点
  return pre;
};
```

```javascript
// 双链表
function doubleReverse(head) {
  let next = new Node();
  let pre = new Node();
  while (head !== null) {
    next = head.next;
    head.next = pre;
    head.last = next;
    pre = head;
    head = next;
  }
  return pre;
}
```

<a name="VWqYk"></a>

###### 环形链表

判断是否是环形列表

```javascript
/**
 * @param {ListNode} head
 * @return {boolean}
 */
// 入参是头结点
const hasCycle = function (head) {
  // 只要结点存在，那么就继续遍历
  while (head) {
    // 如果 flag 已经立过了，那么说明环存在
    if (head.flag) {
      return true;
    } else {
      // 如果 flag 没立过，就立一个 flag 再往
      下走;
      head.flag = true;
      head = head.next;
    }
  }
  return false;
};
```

```javascript
function hasCycle(head) {
  if (head == null || head.next == null || head.next.next == null) {
    return null;
  }
  let n1 = head.next; // n1 -> slow
  let n2 = head.next.next; // n2 -> fast
  // 判断初次相遇
  while (n1 != n2) {
    if (n2.next == null || n2.next.next == null) {
      return false;
    }
    n2 = n2.next.next;
    n1 = n1.next;
  }
  return true;
}
```

寻找入环节点

```javascript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const detectCycle = function (head) {
  while (head) {
    if (head.flag) {
      return head;
    } else {
      head.flag = true;
      head = head.next;
    }
  }
  return null;
};
```

```javascript
function detectCycle(head) {
  if (head == null || head.next == null || head.next.next == null) {
    return null;
  }
  let n1 = head.next; // n1 -> slow
  let n2 = head.next.next; // n2 -> fast
  // 判断初次相遇
  while (n1 != n2) {
    if (n2.next == null || n2.next.next == null) {
      return null;
    }
    n2 = n2.next.next;
    n1 = n1.next;
  }
  n2 = head; // n2 -> walk again from head
  // 再次相遇寻找入环点
  while (n1 != n2) {
    n1 = n1.next;
    n2 = n2.next;
  }
  return n1;
}
```

<a name="bZ152"></a>

#### 例题

<a name="cbBuq"></a>

###### 打印两个有序链表的公共部分

给定两个有序链表的头指针 head1 和 head2，打印两个链表的公共部分。

- 类似并归排序的 merge 过程
- 两链表同时从头对比
- 值小的链表指针右移
- 当值相等时就是两链表相交的节点，两链接指针一起移动

```javascript
function printCommonPart(head1, head2) {
  while (head1 !== null && head2 !== null) {
    if (head1.value > head2.value) {
      head2 = head2.next;
    } else if (head1.value < head2.value) {
      head1 = head1.next;
    } else {
      head1 = head1.next;
      head2 = head2.next;
    }
  }
}
```

<a name="f3lbD"></a>

###### 判断一个链表是否为回文结构

如：1->2->1，返回 true; 1->2->2->1，返回 true;15->6->15，返回 true; 1->2->3，返回 false。<br />解法一：空间复杂度 O(n)

- 开辟一个 n 空间的数组
- 依次存入链表
- 数组从最后开始弹出与链表从头开始对比

```javascript
function isPalindrome1(head) {
  let stack = [];
  let cur = head;
  while (cur != null) {
    stack.push(cur);
    cur = cur.next;
  }
  while (head != null) {
    if (head.value != stack.pop().value) {
      return false;
    }
    head = head.next;
  }
  return true;
}
```

解法二：空间复杂度 O(1)

- 使用快慢指针寻找链表的中点
- 再将右侧链表反转
- 将反转后的链表与原链表依次对比
- 原链表复原

```javascript
function isPalindrome(head) {
  if (head == null || head.next == null) {
    return true;
  }
  let n1 = head;
  let n2 = head;
  while (n2.next != null && n2.next.next != null) {
    // find mid node
    n1 = n1.next; // n1 -> mid
    n2 = n2.next.next; // n2 -> end
  }
  n2 = n1.next; // n2 -> right part first node
  n1.next = null; // mid.next -> null
  let n3 = null;
  while (n2 != null) {
    // right part convert
    n3 = n2.next; // n3 -> save next node
    n2.next = n1; // next of right node convert
    n1 = n2; // n1 move
    n2 = n3; // n2 move
  }
  n3 = n1; // n3 -> save last node
  n2 = head; // n2 -> left first node
  let res = true;
  while (n1 != null && n2 != null) {
    // check palindrome
    if (n1.value != n2.value) {
      res = false;
      break;
    }
    n1 = n1.next; // left to mid
    n2 = n2.next; // right to mid
  }
  n1 = n3.next;
  n3.next = null;
  while (n1 != null) {
    // recover list
    n2 = n1.next;
    n1.next = n3;
    n3 = n1;
    n1 = n2;
  }
  return res;
}
```

<a name="gpQKq"></a>

###### 将单向链表按某值划分成左边小、中间相等、右边大的形式

给定一个单链表的头节点 head，节点的值类型是整型，再给定一个整 数 pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的 节点，中间部分都是值等于 pivot 的节点，右部分都是值大于 pivot 的节点。<br />解法一：

- 将链表变成数组
- 使用快排的方式将数组做大中小排列
- 最后将数组变为链表

解法二：

- 准备小中大首尾六个节点
- 遍历单项链表，根据大中小一次拼接进对应的首尾节点
- 最后将 6 个节点首尾链接起来(需要判断六个点是否有值情况)

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644317872038-4e35a927-715b-480b-98b5-62e4adba786d.png##averageHue=%23e8e8e8&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=590&id=ua46163ee&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1180&originWidth=2094&originalType=binary&ratio=1&rotation=0&showTitle=false&size=751111&status=done&style=none&taskId=u9e3e8fbb-25d2-4401-8932-1a5051059c7&title=&width=1047)

```javascript
function listPartition(head, pivot) {
  let sH = null; // small head
  let sT = null; // small tail
  let eH = null; // equal head
  let eT = null; // equal tail
  let bH = null; // big head
  let bT = null; // big tail
  let next = null; // save next node
  // every node distributed to three lists
  while (head != null) {
    next = head.next;
    head.next = null;
    if (head.value < pivot) {
      if (sH == null) {
        sH = head;
        sT = head;
      } else {
        sH.next = head;
        sT = head;
      }
    } else if (head.value == pivot) {
      if (eH == null) {
        eH = head;
        eT = head;
      } else {
        eH.next = head;
        eT = head;
      }
    } else {
      if (bH == null) {
        bH = head;
        bT = head;
      } else {
        bH.next = head;
        bT = head;
      }
    }
    head = next;
  }
  // small and equal reconnect
  if (sT != null) {
    sT.next = eH;
    eT = eT == null ? sT : eT;
  }
  // all reconnect
  if (eT != null) {
    eT.next = bH;
  }
  return sH != null ? sH : eH != null ? eH : bH;
}
```

<a name="W99LF"></a>

###### 两个单链表相交的一系列问题

给定两个可能有环也可能无环的单链表，头节点 head1 和 head2。请实 现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返 回 null<br />1、判断是无环还是右环的单链接

- 定义两个快慢指针
- 若两指针相遇则是环结构，快指针到 null 为无环结构
- 当快慢指针相遇后，快指针回到起点，并与慢指针同步走
- 当两指针再次相遇的时候就是入环节点

```javascript
function getLoopNode(head) {
  if (head == null || head.next == null || head.next.next == null) {
    return null;
  }
  let n1 = head.next; // n1 -> slow
  let n2 = head.next.next; // n2 -> fast
  // 判断初次相遇
  while (n1 != n2) {
    if (n2.next == null || n2.next.next == null) {
      return null;
    }
    n2 = n2.next.next;
    n1 = n1.next;
  }
  n2 = head; // n2 -> walk again from head
  // 再次相遇寻找入环点
  while (n1 != n2) {
    n1 = n1.next;
    n2 = n2.next;
  }
  return n1;
}
```

2、根据三种情况做处理

- 一个有环链表一个无环链表（无法相交）
- 同时为无环链表
  - 两条环同时走到最后看最后节点是否相同，相同则相交
  - 记录两条链表的长度，算出两链表的差度差
  - 长链表先走差度差步数，然后两条链表同时前进，相遇的点就是相交点

```javascript
function noLoop(head1, head2) {
  if (head1 == null || head2 == null) {
    return null;
  }
  let cur1 = head1;
  let cur2 = head2;
  let n = 0; //记录长度差
  while (cur1.next != null) {
    n++;
    cur1 = cur1.next;
  }
  while (cur2.next != null) {
    n--;
    cur2 = cur2.next;
  }
  if (cur1 != cur2) {
    return null;
  }
  //	找出最长链表，并先走差值步数
  cur1 = n > 0 ? head1 : head2;
  cur2 = cur1 == head1 ? head2 : head1;
  n = Math.abs(n);
  while (n != 0) {
    n--;
    cur1 = cur1.next;
  }
  while (cur1 != cur2) {
    cur1 = cur1.next;
    cur2 = cur2.next;
  }
  return cur1;
}
```

- 双环链表

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644377664949-e4559414-d227-4796-916c-4ebc86642ba2.png##averageHue=%23f4f4f4&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=653&id=SVUMV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1306&originWidth=2132&originalType=binary&ratio=1&rotation=0&showTitle=false&size=456801&status=done&style=none&taskId=ue3b88e01-9883-4e22-b1d5-f3328a2722f&title=&width=1066)

- 当两个环点入环节点相同，说明相交点如图 2，将入环节点以上部分当成双无环链表处理
- 入环节点不同，取其中一个入环节点绕环走一圈
  - 能遇到另外一个入环节点则两个入环节点都是相交点，如图 3
  - 若遇不到则是两个不相交点环，如图 1

```javascript
function bothLoop(head1, loop1, head2, loop2) {
  let cur1 = null;
  let cur2 = null;
  // 图2
  if (loop1 == loop2) {
    cur1 = head1;
    cur2 = head2;
    let n = 0;
    while (cur1 != loop1) {
      n++;
      cur1 = cur1.next;
    }
    while (cur2 != loop2) {
      n--;
      cur2 = cur2.next;
    }
    cur1 = n > 0 ? head1 : head2;
    cur2 = cur1 == head1 ? head2 : head1;
    n = Math.abs(n);
    while (n != 0) {
      n--;
      cur1 = cur1.next;
    }
    while (cur1 != cur2) {
      cur1 = cur1.next;
      cur2 = cur2.next;
    }
    return cur1;
  } else {
    cur1 = loop1.next;
    while (cur1 != loop1) {
      if (cur1 == loop2) {
        // 图3
        return loop1;
      }
      cur1 = cur1.next;
    }
    // 图1
    return null;
  }
}
```

3、总代码

```javascript
function getIntersectNode(head1, head2) {
  if (head1 == null || head2 == null) {
    return null;
  }
  // 获取入环点
  let loop1 = getLoopNode(head1);
  let loop2 = getLoopNode(head2);
  // 两无环情况
  if (loop1 == null && loop2 == null) {
    return noLoop(head1, head2);
  }
  // 两环情况
  if (loop1 != null && loop2 != null) {
    return bothLoop(head1, loop1, head2, loop2);
  }
  return null;
}
```

<a name="nfwL9"></a>

## 二叉树

<a name="WTHVp"></a>

#### 类型

```javascript
let Node = function (key) {
  this.key = key;
  this.left = null;
  this.right = null;
};
```

<a name="uyjPC"></a>

#### 遍历

前序遍历：访问根–>遍历左子树–>遍历右子树;<br />中序遍历：遍历左子树–>访问根–>遍历右子树;<br />后序遍历：遍历左子树–>遍历右子树–>访问根;<br />广度遍历：按照层次一层层遍历;
<a name="PNHYX"></a>

###### 递归遍历方法

基本的遍历过程可分成三次回到递归函数中

```javascript
var traverse = function (node) {
  if (node) {
    //	1
    preOrderRec(node.left);
    //	2
    preOrderRec(node.right);
    //	3
  }
};
```

整个递归过程到达递归接节点的顺序<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644405245052-21638463-3f46-4439-994a-a2e47b9875ea.png##averageHue=%23ebebeb&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=457&id=ua9964c7f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=914&originWidth=1706&originalType=binary&ratio=1&rotation=0&showTitle=false&size=448477&status=done&style=none&taskId=u7d0494b1-cbc5-4a53-b659-15cfb5203ad&title=&width=853)<br />**1、前序遍历**<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644405442053-1d35f1eb-521c-444e-9261-021b3971de31.png##averageHue=%23dddddd&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=355&id=ub1a041cb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=710&originWidth=2092&originalType=binary&ratio=1&rotation=0&showTitle=false&size=608280&status=done&style=none&taskId=u3ea69a54-41bd-4f03-b1ec-40a4efb2f29&title=&width=1046)<br />将遍历过程中的第一次进入递归函数的节点收集起来就是前序遍历

```javascript
var preListRec = []; //定义保存先序遍历结果的数组
var preOrderRec = function (node) {
  if (node) {
    //判断二叉树是否为空
    preListRec.push(node.value); //将结点的值存入数组中
    preOrderRec(node.left); //递归遍历左子树
    preOrderRec(node.right); //递归遍历右子树
  }
};
preOrderRec(tree);
console.log(preListRec);
```

**2、中序遍历**<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644405613629-42d7c61c-7976-4826-a960-3bf321504612.png##averageHue=%23e2e2e2&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=613&id=u736e27bc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1226&originWidth=2072&originalType=binary&ratio=1&rotation=0&showTitle=false&size=901631&status=done&style=none&taskId=u9e362822-6ae7-4122-9cac-cbbac02c74c&title=&width=1036)<br />将第二次进入递归函数时候的节点收集起来

```javascript
var inListRec = []; //定义保存中序遍历结果的数组
var inOrderRec = function (node) {
  if (node) {
    //判断二叉树是否为空
    inOrderRec(node.left); //递归遍历左子树
    inListRec.push(node.value); //将结点的值存入数组中
    inOrderRec(node.right); //递归遍历右子树
  }
};
inOrderRec(tree);
console.log(inListRec);
```

**3、后序遍历**<br />将第三次进入递归函数时候的节点收集起来

```javascript
var postListRec = []; //定义保存后序遍历结果的数组
var postOrderRec = function (node) {
  if (node) {
    //判断二叉树是否为空
    postOrderRec(node.left); //递归遍历左子树
    postOrderRec(node.right); //递归遍历右子树
    postListRec.push(node.value); //将结点的值存入数组中
  }
};
postOrderRec(tree);
console.log(postListRec);
```

<a name="RK0yq"></a>
######## 非递归遍历方法
**1、前序遍历**

- 本地构建一个栈，并将根节点放入
- 循环栈，先弹出节点，然后再按节点的右左节点入栈
- 直到栈完全弹空停止![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644406752749-2b36ba73-11b9-4107-860f-be7e026c2377.png##averageHue=%23a09a93&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=uf98736ec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=666&originWidth=1964&originalType=binary&ratio=1&rotation=0&showTitle=false&size=701185&status=done&style=none&taskId=uf071dc14-6cf7-455e-9ffd-4fdb1289550&title=&width=982)

```javascript
var preListUnRec = []; //定义保存先序遍历结果的数组
var preOrderUnRecursion = function (node) {
  if (node) {
    //判断二叉树是否为空
    var stack = [node]; //将二叉树压入栈
    while (stack.length !== 0) {
      //如果栈不为空，则循环遍历
      node = stack.pop(); //从栈中取出一个结点
      preListUnRec.push(node.value); //将取出结点的值存入数组中
      if (node.right) stack.push(node.right); //如果存在右子树，将右子树压入栈
      if (node.left) stack.push(node.left); //如果存在左子树，将左子树压入栈
    }
  }
};
preOrderUnRecursion(tree);
console.log(preListUnRec);
```

**2、中序遍历**

- **本地构建一个栈**
- **将当前节点深度遍历，将所有的左节点放入栈中**
- **弹出栈保持，并将当前节点设置为右节点**

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644408347338-30f65f49-00b0-4120-8992-a06b5b0f000b.png##averageHue=%23a39e99&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=ubf7f0dfd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=1550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=454839&status=done&style=none&taskId=u13bedc96-520e-4691-b9e9-540387d4221&title=&width=775)

```javascript
var inListUnRec = []; //定义保存中序遍历结果的数组
var inOrderUnRec = function (node) {
  if (node) {
    //判断二叉树是否为空
    var stack = []; //建立一个栈
    while (stack.length !== 0 || node) {
      //如果栈不为空或结点不为空，则循环遍历
      if (node) {
        //如果结点不为空
        stack.push(node); //将结点压入栈
        node = node.left; //将左子树作为当前结点
      } else {
        //左子树为空，即没有左子树的情况
        node = stack.pop(); //将结点取出来
        inListUnRec.push(node.value); //将取出结点的值存入数组中
        node = node.right; //将右结点作为当前结点
      }
    }
  }
};
```

- **中序遍历的序列规则是 左 〉 中 〉 右，所以需要找到最左节点开始记录**
- **创建一个寻找最左节点路径节点的记录栈，当完成左节点中序遍历后，顺着栈找到父节点继续进行中序遍历**

```javascript
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const inorderTraversal = function (root) {
  // 定义结果数组
  const res = [];
  // 初始化栈结构
  const stack = [];
  // 用一个 cur 结点充当游标
  let cur = root;
  // 当 cur 不为空、或者 stack 不为空时，重复以下逻辑
  while (cur || stack.length) {
    // 这个 while 的作用是把寻找最左叶子结点的过程中，途径的所有结点都记录下来
    while (cur) {
      // 将途径的结点入栈
      stack.push(cur);
      // 继续搜索当前结点的左孩子
      cur = cur.left;
    }
    // 取出栈顶元素
    cur = stack.pop();
    // 将栈顶元素入栈
    res.push(cur.val);
    // 尝试读取 cur 结点的右孩子
    cur = cur.right;
  }
  // 返回结果数组
  return res;
};
```

**3、后序遍历**

- **本地构建两个栈 1、栈 2，将根节点放入栈 1**
- **栈 1 弹出，放入栈 2，按先右后左的顺序放入栈 1**
- **直到栈 1 弹完，此时栈 2 的顺序与后序顺序相反**

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644410448386-d5b25b08-2be7-40e0-8f98-8fc79be385b1.png##averageHue=%2396908b&clientId=u0cb154ab-d23b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=292&id=u84b0ed03&margin=%5Bobject%20Object%5D&name=image.png&originHeight=584&originWidth=1550&originalType=binary&ratio=1&rotation=0&showTitle=false&size=523628&status=done&style=none&taskId=u4b652431-7ccb-485c-8542-22c5f188e2d&title=&width=775)

```javascript
var inListUnRec = []; //定义保存中序遍历结果的数组
var posOrderUnRec = function (node) {
  if (node) {
    //判断二叉树是否为空
    var stack1 = [node];
    var stack2 = [];
    while (stack1.length !== 0) {
      node = stack1.pop();
      stack2.push(node);
      if (node.left) stack1.push(node.left);
      if (node.right) stack1.push(node.right);
    }
    inListUnRec = stack2.reverse();
  }
};
```

- 后序遍历的顺序是左〉右〉根，需要将根放在最里面，可以将先序入栈的 push 改为 unshift 记录，此时就是根会压在最后
- 由于是使用 unshift 记录，所以左节点要最后出栈，所以要调整下左右节点入栈顺序

```javascript
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
const postorderTraversal = function (root) {
  // 定义结果数组
  const res = [];
  // 处理边界条件
  if (!root) {
    return res;
  }
  // 初始化栈结构
  const stack = [];
  // 首先将根结点入栈
  stack.push(root);
  // 若栈不为空，则重复出栈、入栈操作
  while (stack.length) {
    // 将栈顶结点记为当前结点
    const cur = stack.pop();
    // 当前结点就是当前子树的根结点，把这个结点放在结果数组的头部
    res.unshift(cur.val);
    // 若当前子树根结点有左孩子，则将左孩子入栈
    if (cur.left) {
      stack.push(cur.left);
    }
    // 若当前子树根结点有右孩子，则将右孩子入栈
    if (cur.right) {
      stack.push(cur.right);
    }
  }
  // 返回结果数组
  return res;
};
```

<a name="K6aQY"></a>
######## 广度遍历

- 使用数组模拟队列，首先将根结点归入队列。
- 当队列不为空时，执行循环：
  - 取出队列的一个结点
  - 如果该节点有左子树，则将该节点的左子树存入队列；
  - 如果该节点有右子树，则将该节点的右子树存入队列。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644411000596-98ba3ef7-df74-4568-8e29-1ef8f8e509a4.png##averageHue=%239a9591&clientId=ue9171a4f-369f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=190&id=u2a7313f2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=1246&originalType=binary&ratio=1&rotation=0&showTitle=false&size=384318&status=done&style=none&taskId=u4c65c53d-a0e5-4162-bb64-535381290fb&title=&width=623)

```javascript
var breadthList = []; //定义保存广度遍历结果的数组
var breadthTraversal = function (node) {
  if (node) {
    //判断二叉树是否为空
    var que = [node]; //将二叉树放入队列
    while (que.length !== 0) {
      //判断队列是否为空
      node = que.shift(); //从队列中取出一个结点
      breadthList.push(node.value); //将取出结点的值保存到数组
      if (node.left) que.push(node.left); //如果存在左子树，将左子树放入队列
      if (node.right) que.push(node.right); //如果存在右子树，将右子树放入队列
    }
  }
};
breadthTraversal(tree);
console.log(breadthList);
```

<a name="SxFvC"></a>
######## 层序遍历

- 使用队列结构记录每层的数据
- 关键在于如何判断该层已经遍历完毕，使用 len 在遍历前记录队列长度，此时为该层数量，由于在遍历过程中队列会不断新增元素，所以需要提前记录长度

```javascript
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
const levelOrder = function (root) {
  // 初始化结果数组
  const res = [];
  // 处理边界条件
  if (!root) {
    return res;
  }
  // 初始化队列
  const queue = [];
  // 队列第一个元素是根结点
  queue.push(root);
  // 当队列不为空时，反复执行以下逻辑
  while (queue.length) {
    // level 用来存储当前层的结点
    const level = [];
    // 缓存刚进入循环时的队列长度，这一步很关键，因为队列长度后面会发生改变
    const len = queue.length;
    // 循环遍历当前层级的结点
    for (let i = 0; i < len; i++) {
      // 取出队列的头部元素
      const top = queue.shift();
      // 将头部元素的值推入 level 数组
      level.push(top.val);
      // 如果当前结点有左孩子，则推入下一层级
      if (top.left) {
        queue.push(top.left);
      }
      // 如果当前结点有右孩子，则推入下一层级
      if (top.right) {
        queue.push(top.right);
      }
    }
    // 将 level 推入结果数组
    res.push(level);
  }
  // 返回结果数组
  return res;
};
```

**求二叉树的最大宽度**

- 准备最大宽度，当前层最大宽度，当前层数，节点所在层数的对应表
- 按宽度遍历进行，左右节点存在的时候，存储左右节点对应的层数
- 当前层数大于等于当前节点层数的时候，当前层数宽度加一
- 当前层数小于当前节点层数的时候，说明已经换层，当前层数重置，当前层数加一
- 每次循环对比最大宽度和当前层的宽度，取最大值更新

```javascript
var getMaxWidth = function (node) {
  let maxWidth = 0;
  let curWidth = 0;
  let curLevel = 1;
  let leveMap = new Map();
  let queue = [node];
  leveMap.set(node, 1);
  while (queue.length !== 0) {
    node = queue.shift();
    let left = queue.left;
    let right = queue.right;
    if (left) {
      leveMap.set(left, leveMap.get(node) + 1);
      queue.push(left);
    }
    if (right) {
      leveMap.set(right, leveMap.get(node) + 1);
      queue.push(right);
    }
    if (leveMap.get(node) > curLevel) {
      curWidth = 0;
      curLevel = leveMap.get(node);
    } else {
      curWidth++;
    }
    maxWidth = Math.max(maxWidth, curWidth);
  }
  return maxWidth;
};
```

<a name="c9Qgd"></a>

#### 二叉树的相关概念及其实现判断

<a name="oCRKa"></a>

###### 搜索二叉树

所有节点满足：<br />若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值<br />若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
<a name="Ejgb5"></a>
######## 搜索二叉树判断
解法一：

- 根据题意，中序遍历的顺序为左中右，可在中序递归遍历过程做大小判断
- 用全局变量记录前一个节点的值
- 当中序遍历的时候
- 前一个节点的值大于当前节点值是非搜索二叉树
- 前一个节点的值小于等于当前节点值时，更新变量

```javascript
var minValue = Number.MIN_VALUE;
function isBST(node) {
  if (node === null) return true;
  isBST(node.left);
  if (node.value > minValue) {
    minValue = node.value;
  } else {
    return false;
  }
  isBST(node.right);
}
```

解法二：(动态规划)

- 根据搜索二叉树性质，得出需要向上传递的是当前节点左右数的最大值和最小值
- 解决最底层的最大值和最小值是自身，依次向上传递比较

```javascript
function checkBST(node) {
  process(node).isBST;
}

function process(node) {
  if (node === null) {
    return null;
  }

  let leftDate = process(node.left);
  let rightDate = process(node.right);
  let min = node.value;
  let max = node.value;

  if (leftDate !== null) {
    min = Math.min(min, leftDate.min);
    max = Math.max(max, leftDate.max);
  }

  if (rightDate !== null) {
    min = Math.min(min, leftDate.min);
    max = Math.max(max, leftDate.max);
  }

  let isBST = true;
  if (leftDate !== null && (!leftDate.isBST || leftDate.max >= node.value)) {
    isBST = false;
  }

  if (rightDate !== null && (rightDate.isBST || rightDate.min <= node.value)) {
    isBST = false;
  }

  return {
    isBST,
    min,
    max,
  };
}
```

- 利用左 < 根 < 右关系进行判断
- 设立两个极端-Infinity, Infinity，为了兼容左右树用同一套判断逻辑
- 当检验左树的时候，root.val <= minValue 必定不成立，若 root.val >= maxValue，说明左〉根，不成立
- 当检验右树的时候，root.val >= maxValue 必定不成立，若 root.val <= minValue ，说明根〉右，不成立

```javascript
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
const isValidBST = function (root) {
  // 定义递归函数
  function dfs(root, minValue, maxValue) {
    // 若是空树，则合法
    if (!root) {
      return true;
    }
    // 若右孩子不大于根结点值，或者左孩子不小于根结点值，则不合法
    if (root.val <= minValue || root.val >= maxValue) return false;
    // 左右子树必须都符合二叉搜索树的数据域大小关系
    return (
      dfs(root.left, minValue, root.val) && dfs(root.right, root.val, maxValue)
    );
  }
  // 初始化最小值和最大值为极小或极大
  return dfs(root, -Infinity, Infinity);
};
```

<a name="zOoLC"></a>
######## 查找节点

- 与二分发查找类似
- 用查找值与当前节点值对比，小于则从左侧树向下递归，大于则从右侧树递归
- 当最后节点为空还未找到则值不存在

```javascript
function search(root, n) {
  // 若 root 为空，查找失败，直接返回
  if (!root) {
    return;
  }
  // 找到目标结点，输出结点对象
  if (root.val === n) {
    console.log("目标结点是：", root);
  } else if (root.val > n) {
    // 当前结点数据域大于n，向左查找
    search(root.left, n);
  } else {
    // 当前结点数据域小于n，向右查找
    search(root.right, n);
  }
}
```

<a name="J58qc"></a>
######## 插入新结点

- 寻找最后的末点进行插入
- 和查找一样用二分法找到最后合适的点
- 当节点为空的时候就是插入的位置，在此处新建节点插入

```javascript
function insertIntoBST(root, n) {
  // 若 root 为空，说明当前是一个可以插入的空位
  if (!root) {
    // 用一个值为n的结点占据这个空位
    root = new TreeNode(n);
    return root;
  }

  if (root.val > n) {
    // 当前结点数据域大于n，向左查找
    root.left = insertIntoBST(root.left, n);
  } else {
    // 当前结点数据域小于n，向右查找
    root.right = insertIntoBST(root.right, n);
  }

  // 返回插入后二叉搜索树的根结点
  return root;
}
```

<a name="b17WH"></a>
######## 删除节点

- 当删除点无左右树的时候，直接删除
- 当只有左/右节点的时候，将左/右节点接入到父节点的左/右树上，相当于用左/右树节点代替删除的节点

![20170313153634034.gif](https://cdn.nlark.com/yuque/0/2023/gif/1350314/1673333838401-2dbad286-8bec-425a-8133-7bc3d5324bce.gif##averageHue=%23faf0e9&clientId=u00f03651-1e80-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufcbad7e7&margin=%5Bobject%20Object%5D&name=20170313153634034.gif&originHeight=281&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=37478&status=done&style=none&taskId=uc816e695-f043-4b74-beda-7a367c8cab1&title=)

- 当同时存在左右树的时候，可以将左树中的最大值代替删除节点；或将右树最小值代替删除节点
  - 删除 58

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1350314/1673333999337-4840592c-3bf3-4c39-94e2-dd7462e14576.png##averageHue=%23f7dede&clientId=u00f03651-1e80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=239&id=ucdf50ae2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=478&originWidth=659&originalType=binary&ratio=1&rotation=0&showTitle=false&size=45483&status=done&style=none&taskId=ucc1f8e88-8203-41d0-a9ca-89b66a3388a&title=&width=329.5)

- 寻找右树最小值 59

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1350314/1673334011058-1fa7a265-56ae-499d-8546-6b7b011267f6.png##averageHue=%23f8e4e4&clientId=u00f03651-1e80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=253&id=uedb91f90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=506&originWidth=743&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49593&status=done&style=none&taskId=ucdac346d-f1f1-4266-ba64-bf625448030&title=&width=371.5)

- 将 59 的替换到 58

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1350314/1673334057833-ebdbfafb-04e9-4b0d-b71e-8e8c633beac2.png##averageHue=%23f9e7e7&clientId=u00f03651-1e80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=255&id=ub8db8c4f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=510&originWidth=774&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47385&status=done&style=none&taskId=u477963d9-1fbb-44e7-9247-c35b365b167&title=&width=387)

```javascript
function deleteNode(root, n) {
  // 如果没找到目标结点，则直接返回
  if (!root) {
    return root;
  }
  // 定位到目标结点，开始分情况处理删除动作
  if (root.val === n) {
    // 若是叶子结点，则不需要想太多，直接删除
    if (!root.left && !root.right) {
      root = null;
    } else if (root.left) {
      // 只有左树或者左右树都存在情况
      // 寻找左子树里值最大的结点
      const maxLeft = findMax(root.left);
      // 用这个 maxLeft 覆盖掉需要删除的当前结点，将左树最大值替换到当前节点
      root.val = maxLeft.val;
      // 覆盖动作会消耗掉原有的 maxLeft 结点，此时最大节点必然是树的末端，在调用回
      // 删除节点，把原来位置的最大值节点删除
      root.left = deleteNode(root.left, maxLeft.val);
    } else {
      // 寻找右子树里值最小的结点
      const minRight = findMin(root.right);
      // 用这个 minRight 覆盖掉需要删除的当前结点
      root.val = minRight.val;
      // 覆盖动作会消耗掉原有的 minRight 结点
      root.right = deleteNode(root.right, minRight.val);
    }
  } else if (root.val > n) {
    // 若当前结点的值比 n 大，则在左子树中继续寻找目标结点
    root.left = deleteNode(root.left, n);
  } else {
    // 若当前结点的值比 n 小，则在右子树中继续寻找目标结点
    root.right = deleteNode(root.right, n);
  }
  return root;
}

// 寻找左子树最大值
function findMax(root) {
  while (root.right) {
    root = root.right;
  }
  return root;
}

// 寻找右子树的最小值
function findMin(root) {
  while (root.left) {
    root = root.left;
  }
  return root;
}
```

<a name="rD6qn"></a>
######## 将排序数组转化为二叉搜索树

- 不断的从数组中间切分作为根节点
- 使用递归切分到最后

```javascript
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
const sortedArrayToBST = function (nums) {
  // 处理边界条件
  if (!nums.length) {
    return null;
  }

  // root 结点是递归“提”起数组的结果
  const root = buildBST(0, nums.length - 1);

  // 定义二叉树构建函数，入参是子序列的索引范围
  function buildBST(low, high) {
    // 当 low > high 时，意味着当前范围的数字已经被递归处理完全了
    if (low > high) {
      return null;
    }
    // 二分一下，取出当前子序列的中间元素
    const mid = Math.floor(low + (high - low) / 2);
    // 将中间元素的值作为当前子树的根结点值
    const cur = new TreeNode(nums[mid]);
    // 递归构建左子树，范围二分为[low,mid)
    cur.left = buildBST(low, mid - 1);
    // 递归构建左子树，范围二分为为(mid,high]
    cur.right = buildBST(mid + 1, high);
    // 返回当前结点
    return cur;
  }
  // 返回根结点
  return root;
};
```

<a name="N04Z5"></a>

###### 判断完全二叉树

若设二叉树的深度为 h，除第 h 层外，其它各层 (1 ～ h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644491870930-212f887e-6559-4643-b1f3-40fd039d0498.png##averageHue=%23585828&clientId=ue9171a4f-369f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=155&id=uab1459eb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=310&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141438&status=done&style=none&taskId=u966a33e1-c306-484e-aec3-00924132f4f&title=&width=291)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644492036518-c8ab0d26-9b37-46a2-87a0-ef478f56ea6f.png##averageHue=%23e9e9e9&clientId=ue9171a4f-369f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=638&id=u35a5d079&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1276&originWidth=2144&originalType=binary&ratio=1&rotation=0&showTitle=false&size=799805&status=done&style=none&taskId=u95cc8afb-2625-48bd-b021-a4a65fe0b16&title=&width=1072)

- 用 leaf 保存是否发生过左右子不全的情况
- 宽度遍历
  - 当发生左节点存在，右节点不存在的时候，修改 leaf
  - 满足 1、2 条件的时候退出

```javascript
var leaf = false;
function isCBT(node) {
  if (node === null) return true;
  let stack = [node];
  while (stack.length !== 0) {
    node = stack.shift();
    let left = node.left;
    let right = node.left;

    // 左节点无右节点有，不满足
    // 当 该层有节点存在，左有右无情况，它的下一个节点需要满足无左右节点条件
    if (
      (left === null && right) ||
      (leaf && (left !== null || right !== null))
    ) {
      return false;
    }

    if (left !== null) {
      node.push(left);
    }
    if (right !== null) {
      node.push(right);
    } else {
      leaf = true;
    }
  }
}
```

<a name="Bcy86"></a>

###### 判断满二叉树

对于满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，满足深度为 k 的二叉树至多总共有 2^(k+1)-1 个节点<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644492837864-9e36117f-d829-4eae-a62d-d4229836070f.png##averageHue=%2310126c&clientId=ue9171a4f-369f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=142&id=uca51241e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=283&originWidth=436&originalType=binary&ratio=1&rotation=0&showTitle=false&size=130887&status=done&style=none&taskId=u747e308f-a78f-403e-a40e-c74ffb04fca&title=&width=218)

```javascript
function checkFBT(node) {
  let info = process(node).isFBT;
  return info.nodes === Math.pow(2, info.height - 1);
}

function process(node) {
  if (node === null) {
    return {
      nodes: 0,
      height: 0,
    };
  }

  let leftData = process(node.left);
  let rightData = process(node.right);

  let nodes = leftData.nodes + rightData.nodes + 1;
  let height = Math.max(leftData.height, rightData.height) + 1;

  return {
    nodes,
    height,
  };
}
```

<a name="Ze0kv"></a>

###### 判断平衡二叉树

它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1

- 使用动态规划递归方法
- 先处理末节点为 null 的情况，保证能从最低层一直向上传递
- 递归过程中需要返回两值作为判断依据（当前节点是否为平衡二叉树、当前节点树的深度）

```javascript
function checkBalance(node) {
  process(node).isBalance;
}

function process(node) {
  if (node === null) {
    return {
      height: 0,
      isBalance: true,
    };
  }

  let leftDate = process(node.left);
  let rightDate = process(node.right);

  let height = Math.max(leftDate.height, rightDate.height) + 1;
  let isBalance =
    (leftDate.isBalance && rightDate.isBalance) ||
    Math.abs(leftDate.height - rightDate.height) < 2;

  return {
    height,
    isBalance,
  };
}
```

<a name="CJqPs"></a>

###### 序列化和反序列化

就是内存里的一棵树如何变成字符串形式，又如何从字符串形式变成内存里的树<br />利用前序遍历做序列化

```javascript
function serialByPre(head) {
  if (head == null) {
    return "##!";
  }
  let res = head.value + "!";
  res += serialByPre(head.left);
  res += serialByPre(head.right);
  return res;
}
```

反序列化，根据正序列化的顺序头，左，右，使用队列出栈还原

```javascript
function reconByPreString(preStr) {
  let values = preStr.split("!");
  let queue = [];
  for (let i = 0; i < values.length; i++) {
    queue.push(values[i]);
  }
  return reconPreOrder(queue);
}

function reconPreOrder(queue) {
  let value = queue.shift();
  if (value.includes("##")) {
    return null;
  }
  let head = new Node(value);
  head.left = reconPreOrder(queue);
  head.right = reconPreOrder(queue);
  return head;
}
```

<a name="ORhD6"></a>

## 图

<a name="sYdi6"></a>

#### 图的存储类型

<a name="g0ko3"></a>

###### 邻接表

- 每个点都是一个集合
- 集合里面存储接邻的点和到该点的权重

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644729645396-3a919694-91ab-436d-ba38-ca706ef1bb4d.png##averageHue=%23ebebeb&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=590&id=u655ecd41&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1180&originWidth=1778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=544895&status=done&style=none&taskId=ub875769a-c676-4803-bd5a-0ed59d27f84&title=&width=889)

<a name="Zfx6n"></a>

###### 邻接矩阵

- 将每个点转化成 xy 轴
- 值为两点之间的权重，不邻接为正无穷

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644729699766-6f3b866f-0bec-4590-994d-77fb078af64c.png##averageHue=%23e9e9e9&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=552&id=udf956934&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1104&originWidth=1784&originalType=binary&ratio=1&rotation=0&showTitle=false&size=574871&status=done&style=none&taskId=u44d3b76f-8fdb-49f1-8e3e-ad179175e8b&title=&width=892)
<a name="PwSte"></a>

#### 图的表达结构

- 构建常用套路的图表达结构
- 将图转化成自己封装的图表达结构类型

例如先将图转化为一个二位数组

| arr | 权重(weight) | 出发点(from) | 接受点(to) |
| --- | ------------ | ------------ | ---------- |
| 0   |              |              |            |
| 1   |              |              |            |

1. 图 nodes 存储点类的哈希表
2. 图 edge 存储线的方向和权重
3. 点类存储指出和接受线段的数量、下个节点的集合

```javascript
class Node {
  constructor(value) {
    this.value = value;
    this.out = 0;
    this.in = 0;
    this.edges = new Set();
    this.nexts = new Set();
  }
}

class Edge {
  constructor(weight, from, to) {
    this.weight = from;
    this.from = from;
    this.to = to;
  }
}

function createGraph(arr) {
  let graph = {
    nodes: new Map(),
    edges: new Set(),
  };

  arr.forEach((item) => {
    const weight = item[0];
    const from = item[1];
    const to = item[2];
    if (!graph.nodes.has(from)) {
      graph.nodes.set(from, new Node(from));
    }
    if (!graph.edges.has(to)) {
      graph.nodes.set(to, new Node(to));
    }

    let fromNode = graph.nodes.get(from);
    let toNode = graph.nodes.get(to);
    let newEdge = new Edge(weight, fromNode, toNode);
    fromNode.out++;
    toNode.in++;

    fromNode.nexts.add(toNode);
    fromNode.edges.add(newEdge);
    graph.edges.add(newEdge);
  });

  return graph;
}
```

<a name="zyEgN"></a>

#### 图的遍历

利用上面的图表达结构进行遍历
<a name="tgO2j"></a>

###### 宽度遍历

- 利用队列实现
- 从源节点开始依次按照宽度进队列，然后弹出
- 每弹出一个点，把该节点所有没有进过队列的邻接点放入队列
- 直到队列变空

```javascript
function BFS(node) {
  if (node === null) return;
  let queue = [];
  let nodeSet = new Set();
  queue.push(node);
  nodeSet.add(node);

  while (queue.length !== 0) {
    let cur = queue.shift();
    console.log(cur.log);
    cur.nexts.forEach((item) => {
      if (!nodeSet.has(item)) {
        queue.push(item);
        nodeSet.add(item);
      }
    });
  }
}
```

<a name="yTfKX"></a>

###### 深度遍历

- 利用栈实现
- 从源节点开始把节点按照深度放入栈，然后弹出
- 每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈
- 直到栈变空

```javascript
function DFS(node) {
  if (node == null) return;
  let stack = [];
  let nodeSet = new Set();
  stack.push(node);
  nodeSet.add(node);
  console.log(node.value);

  while (stack.length !== 0) {
    let cur = stack.pop();
    console.log(cur.value);
    for (let i = 0; i < cur.length; i++) {
      // 每次只选一只没进行的分支进行深度遍历
      if (!nodeSet.has(cur[i])) {
        stack.push(cur);
        stack.push(next);
        nodeSet.add(cur);
        console.log(cur.value);
        break;
      }
    }
  }
}
```

<a name="F5LtO"></a>

#### 基本算法

<a name="rIAaO"></a>

###### 拓扑排序算法

适用范围:要求有向图，且有入度为 0 的节点，且没有环

- 准备一个存储入度为 0 的数组 zeroInQueue，一个节点和入度数量的对应的字典
- 先找出第一个入 0 的节点放入
- 循环弹出 zeroInQueue，遍历节点的接连点数组，并将对应的字典入度-1，将-1 入度为 0 的节点再次放入 zeroInQueue

```javascript
function TopologySort(graph) {
  let zeroinQueue = [];
  let inMap = new Map();
  let res = [];

  graph.nodes.forEach((item) => {
    inMap.set(item, item.in);
    if (item.in === 0) zeroinQueue.push(item);
  });

  while (zeroinQueue.length !== 0) {
    let cur = zeroinQueue.pop();
    res.push(res);
    cur.nexts.forEach((item) => {
      inMap.set(item, item.in - 1);
      if (inMap.get(item) === 0) {
        zeroinQueue.push(item);
      }
    });
  }
  return res;
}
```

如果是带权值的无向图，那么权值之和最小的生成树，我们就称之为最小生成树(MST, Minimum Spanning Tree)。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644737867810-637e54d4-adf4-41e8-b6d5-f42b2476c524.png##averageHue=%23f9f9f8&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u578e83a5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=228&originWidth=558&originalType=binary&ratio=1&rotation=0&showTitle=false&size=12898&status=done&style=none&taskId=u767e8c2e-bd3e-4a60-97e7-15e10e25c10&title=&width=533)
<a name="NzIEh"></a>

###### kruskal(克鲁斯卡尔)算法

- 先将边从小到大排序
- 为每个节点准备一个对象
- 从最小的边找出对应的节点，并且将两个节所在的对象合并，如果两个节点所在的对象相同则跳过
- 依次遍历所有的边

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739151628-5b446d0a-dd32-479a-bc36-468b35029936.png##averageHue=%23a9a398&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=897&id=ub05b8214&margin=%5Bobject%20Object%5D&name=image.png&originHeight=890&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=337056&status=done&style=none&taskId=u03c9483c-d82b-49ae-9911-5100ee5cd44&title=&width=669)

```javascript
class UnionFind {
  constructor() {
    this.faterMap = new Map();
  }

  makeSets(nodes) {
    nodes.forEach((item) => {
      this.faterMap.set(item, [item]);
    });
  }

  isSameSet(nodeA, nodeB) {
    return this.faterMap.get(nodeA) === this.faterMap.get(nodeB);
  }

  union(nodeA, nodeB) {
    let aFather = this.get(nodeA);
    let bFather = this.get(nodeB);
    let unionFather = [...aFather, ...bFather];
    this.faterMap.set(nodeA, unionFather);
    this.faterMap.set(nodeB, unionFather);
  }
}

function kruskalMST(graph) {
  let unionFind = new UnionFind();
  unionFind.makeSets(graph.nodes);
  let priorityQueue = graph.edges.sort(a, (b) => b.value - a.value);
  let result = [];

  while (priorityQueue.lenght !== 0) {
    let edge = priorityQueue.pop();
    if (!UnionFind.isSameSet(edge.from, edge.to)) {
      result.push(edge);
      unionFind.union(edge.from, edge, to);
    }
  }
  return result;
}
```

<a name="KarEx"></a>

#### Prim(普林姆)算法

- 选择一个节点为起点
- 在它所连接的边中选择权重最小的边寻找下个节点，并放入集合中
- 在集合中点所连接的边中，继续寻找权重最小的边连接到下个点，知道集合为全部节点
  | 图例 | 说明 | 不可选 | 可选 | 已选（Vnew） |
  | --- | --- | --- | --- | --- |
  | <br />![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628185-f530f54e-03df-4e7c-a538-f8027dc398f5.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u54ae3aab&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ude709dd4-b25b-418c-8c11-e032b9ec7b6&title=) | 此为原始的加权连通图。每条边一侧的数字代表其权值。 | - | - | - |
  | ![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628213-e8158686-c968-4e5b-afed-bf3aba077873.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8176cca4&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u640c7524-a40e-4dab-bb5b-9ff76c45d1c&title=) | 顶点**D**被任意选为起始点。顶点**A**、**B**、**E**和**F**通过单条边与**D**相连。**A**是距离**D**最近的顶点，因此将**A**及对应边**AD**以高亮表示。 | C, G | A, B, E, F | D |
  | <br />![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628219-dca56a9c-2411-4224-96bd-1f4b2532a431.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue7914118&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9894c54f-3a8a-4b10-bd7c-df74a3ad015&title=) | 下一个顶点为距离**D**或**A**最近的顶点。**B**距**D**为 9，距**A**为 7，**E**为 15，**F**为 6。因此，**F**距**D**或**A**最近，因此将顶点**F**与相应边**DF**以高亮表示。 | C, G | B, E, F | A, D |
  | ![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628180-61b5f617-8b52-4491-8068-1d895be791ef.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u35ab3885&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc6ee90da-d27e-4abe-935f-e9406b8dd2f&title=) | 算法继续重复上面的步骤。距离**A**为 7 的顶点**B**被高亮表示。 | C | B, E, G | A, D, F |
  | <br />![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628228-ec8471bd-841c-4747-9a47-6e99bf007d30.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4fbff6b5&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u22713e21-af3d-4698-8092-0beb1d350c0&title=) | 在当前情况下，可以在**C**、**E**与**G**间进行选择。**C**距**B**为 8，**E**距**B**为 7，**G**距**F**为 11。**E**最近，因此将顶点**E**与相应边**BE**高亮表示。 | 无 | C, E, G | A, D, F, B |
  | <br />![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628651-8bc73e4f-5a31-4b0e-8e9b-84fb9fe6211b.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uecc4c599&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uaba78e71-6b48-441b-abcb-96f8268407c&title=) | 这里，可供选择的顶点只有**C**和**G**。**C**距**E**为 5，**G**距**E**为 9，故选取**C**，并与边**EC**一同高亮表示。 | 无 | C, G | A, D, F, B, E |
  | ![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628873-80c6f339-e1ad-4bd5-8a1d-334d1565df1d.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ufa36ddfd&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u32d90983-87da-4577-9209-7260519e44e&title=) | 顶点**G**是唯一剩下的顶点，它距**F**为 11，距**E**为 9，**E**最近，故高亮表示**G**及相应边**EG**。 | 无 | G | A, D, F, B, E, C |
  | ![](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644739628799-7f9783e7-c335-4a5e-bd50-949f6f72d6c0.png##averageHue=%23000000&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u9c561891&margin=%5Bobject%20Object%5D&originHeight=518&originWidth=618&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u51ccec37-b578-4d85-9033-835d5e3c384&title=) | 现在，所有顶点均已被选取，图中绿色部分即为连通图的最小生成树。在此例中，最小生成树的权值之和为 39。 | 无 | 无 | A, D, F, B, E, C, G |

```javascript
function primMST(graph) {
  //每新增一个元素就会按边的权重从小到大排序
  let priorityQueue = new PriorityQueue();
  let nodeSet = new Set();
  let result = [];

  graph.nodes.forEach((item) => {
    if (!nodeSet.has(item)) {
      nodeSet.add(item);
      item.edges.forEach((edge) => priorityQueue.push(edge));
    }

    while (priorityQueue.lenght !== 0) {
      let edge = priorityQueue.pop();
      let toNode = edge.to;
      if (!nodeSet.has(toNode)) {
        nodeSet.add(toNode);
        result.push(edge);
        toNode.edges.forEach((toNodeEdge) => priorityQueue.push(toNodeEdge));
      }
    }
  });
  return result;
}
```

[https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/30/2615542.html)
<a name="xdAKm"></a>
######## Dijkstra(迪杰斯特拉)算法
计算一个节点到其他节点的最短路径。<br />适用范围:没有权值为负数的边

- 设计一个表，每个表到起点位置权重为正无穷
- 起点将所有链接到节点权重更新进表中，选择距离最短的作为下次的起点
- 再次将所有连接到的节点的权重与原来的相比，小的更新进表中

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644743435922-49f53017-5410-41c0-a0f4-62320a92c00a.png##averageHue=%239e968a&clientId=udaf7f75c-9772-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=289&id=ua6d52b82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=1138&originalType=binary&ratio=1&rotation=0&showTitle=false&size=480369&status=done&style=none&taskId=u897a8454-bd7d-4b11-982f-1c42428374d&title=&width=569)

```javascript
function Dijkstra(head) {
  let distanceMap = new Map();
  distanceMap.set(head, 0);
  let selectNode = new Set();

  let minNode = getMinDistanceAndUnselectedNode(distanceMap, selectNode);

  while (minNode != null) {
    let distance = distanceMap.get(minNode);
    minNode.edges.forEach((item) => {
      let toNode = item.to;
      if (!distanceMap.get(toNode)) {
        distanceMap.set(toNode, distance + edge.weight);
      } else {
        distanceMap.set(
          toNode,
          Math.min(distanceMap.get(toNode), distance + edge.weight)
        );
      }
    });
    selectNode.add(minNode);
    minNode = getMinDistanceAndUnselectedNode(distanceMap, selectNode);
  }
}

function getMinDistanceAndUnselectedNode(distanceMap, selectNode) {
  let minNode = null;
  let minDistance = Number.MAX_VALUE;

  distanceMap.forEach((node, key) => {
    if (!selectNode.has(node) && value < minDistance) {
      minNode = node;
      minDistance = value;
    }
  });
  return minNode;
}
```

<a name="zUWH3"></a>

## 前缀树

前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644826156401-43bdfb22-72ef-4fc1-8f7b-6dae882da46f.png##averageHue=%23222222&clientId=u223860be-745e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=235&id=u00cbea94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&size=39530&status=done&style=none&taskId=uc478749e-c99e-421c-8364-3dd8d24bf67&title=&width=250)
<a name="S9ak8"></a>

#### 前缀树构建(以 26 小写字母为例)

- 定义树节点
  - path：经过节点的次数
  - end：以该节点结束的次数
  - nexts：存储下个连接的节点
- 根节点默认是空元素，每注入一个树分支，path+1
- 若不是小写字母，nexts 可用 hasMap 记录，nexts 主要是用于保存唯一 key 的连接节点

```javascript
class TriedNode {
  constructor() {
    this.path = 0;
    this.end = 0;
    this.nexts = new Array(26);
  }
}

class TrieTeee {
  constructor() {
    this.root = new TriedNode();
    this.startAscii = "a".charCodeAt();
  }

  insert(word) {
    if (word === null) return;
    let chs = word.split("");
    let index = 0;
    let node = this.root;
    chs.forEach((i) => {
      index = i.charCodeAt() - this.startAscii;
      if (!node.nexts[index]) {
        node.nexts[index] = new TriedNode();
      }
      node = node.nexts[index];
      node.path++;
    });
    node.end++;
  }

  delete(word) {
    if (word === null) return;
    let chs = word.split("");
    let index = 0;
    let node = this.root;

    chs.forEach((i) => {
      index = i.charCodeAt() - this.startAscii;
      // 经过的节点树-1，减后如果为0说明该节点没有经过的字符串了，删除节点
      if (--node.nexts[index].path === 0) {
        node.nexts[index] === null;
        return;
      }
      node = node.nexts[index];
    });
    node.end--;
  }

  search(word) {
    if (word === null) return;
    let chs = word.split("");
    let index = 0;
    let node = this.root;

    for (let i = 0; i < chs.length; i++) {
      index = chs[i].charCodeAt() - this.startAscii;
      // 不存在下个连接的节点，则未保存该字符串返回0
      if (node.nexts[index] === null) {
        return 0;
      }
      node = node.nexts[index];
    }
    return node.end;
  }

  // 以某个前缀为开头的字符串数
  prefixNumber(pre) {
    if (pre === null) return;
    let chs = pre.split("");
    let index = 0;
    let node = this.root;

    for (let i = 0; i < chs.length; i++) {
      index = chs[i].charCodeAt() - this.startAscii;
      if (node.nexts[index] === null) {
        return 0;
      }
      node = node.nexts[index];
    }
    return node.path;
  }
}
```

<a name="cWVjM"></a>

## 贪心算法

在某一个标准下，优先考虑最满足标准的样本，最后考虑最不满足标准的样本，最终得到一个答案的算法，叫作贪心算法。<br />也就是说，不从整体最优上加以考虑，所做出的是在某种意义上的局部最优解。<br /> 局部最优 -?-> 整体最优
<a name="B2mZG"></a>

#### 解题思路

- 实现一个不依靠贪心策略的解法 X，可以用最暴力的尝试
- 脑补出贪心策略 A、贪心策略 B、贪心策略 C...，重点是根据经验想出贪心策略
  - 根据某标准建立一个比较器来排序
  - 根据某标准建立一个比较器来组成堆
- 先用反推法将不成立的贪心策略排除
- 再用解法 X 和对数器，去验证每一个贪心策略，用实验的方式得知哪个贪心策略正确
- 不要去纠结贪心策略的证明
  <a name="GPiyk"></a>

#### 例题

给定一个字符串类型的数组 strs，找到一种拼接方式，使得把所有字符串拼起来之后形成的 字符串具有最小的字典序。

- 字典序，将字符串看成 26 进制的数字进行排序比较
- 长短不一的字典序，短的后面补 0 再进行比较
- 贪心策略：前后两字符串按前后、后前顺序拼接比较，小的排序前面

```javascript
function lowestString(strs) {
  strs = strs.sort((a, b) => {
    // compare为比较字典序方法
    return compare(a + b, b + a);
  });
  let res = "";
  strs.forEach((i) => (res += i));
  return res;
}
```

一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。 给你每一个项目开始的时间和结束的时间(给你一个数 组，里面是一个个具体 的项目)，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。 返回这个最多的宣讲场次。

- 贪心策略：按结束时间的先后顺序排列
- 按排列后的顺序依次排满足时间的会议

```javascript
function bestArrange(programs, start) {
  programs = programs.sort((a, b) => a.end - b.end);
  let res = [];
  programs.forEach((item) => {
    if (item.start >= start) {
      res.push(item);
      start = item.end;
    }
  });
  return res;
}
```

一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为 20 的金 条，不管切成长度多大的两半，都要花费 20 个铜板。<br />一群人想整分整块金条，怎么分最省铜板? 例如,给定数组{10,20,30}，代表一共三个人，整块金条长度为 10+20+30=60。 金条要分成 10,20,30 三个部分。 如果先把长度 60 的金条分成 10 和 50，花费 60; 再把长度 50 的金条分成 20 和 30，花费 50;一共花费 110 铜板。 但是如果先把长度 60 的金条分成 30 和 30，花费 60;再把长度 30 金条分成 10 和 20， 花费 30;一共花费 90 铜板。<br />输入一个数组，返回分割的最小代价。

- 先将数组放入小根堆，取前两位相加 cur
- 记录当前分割值 cur，将 cur 放入小根堆继续排排序

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644831991526-857329c0-ae81-49be-9b34-44282773250c.png##averageHue=%23a29e98&clientId=u223860be-745e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=427&id=u6e1762ea&margin=%5Bobject%20Object%5D&name=image.png&originHeight=688&originWidth=1100&originalType=binary&ratio=1&rotation=0&showTitle=false&size=604947&status=done&style=none&taskId=u42bfdb0a-8f76-48fe-97b3-15e42e7330b&title=&width=682)

```javascript
funct
ion lessMoney (arr) {
    let pQ = new PriorityQueue()
    arr.forEach(i => pQ.add(i))

    let sum = 0
    let cur = 0
    while (pQ.size > 0) {
        cur = pQ.poll() + pQ.poll()
        sum += cur
        pQ.add(cur)
    }
    return sum
}
```

<a name="Ser7k"></a>

## 递归回溯/动态规划

<a name="rXkxO"></a>

#### 递归回溯

**什么时候用**

1. 题目中暗示了一个或多个解，并且要求我们详尽地列举出每一个解的内容时，一定要想到 DFS、想到递归回溯。
2. 题目经分析后，可以转化为树形逻辑模型求解。

**为什么这样用**<br />递归与回溯的过程，本身就是穷举的过程。题目中要求我们列举每一个解的内容，解从哪来？解是基于穷举思想、对搜索树进行恰当地剪枝后得来的。 <br />**怎么用**<br />一个模型——树形逻辑模型；两个要点——递归式和递归边界。

```javascript
function xxx(入参) {
  前期的变量定义、缓存等准备工作

  // 定义路径栈
  const path = []

  // 进入 dfs
  dfs(起点)

  // 定义 dfs
  dfs(递归参数) {
    if(到达了递归边界) {
      结合题意处理边界逻辑，往往和 path 内容有关
      return
    }

    // 注意这里也可能不是 for，视题意决定
    for(遍历坑位的可选值) {
      path.push(当前选中值)
      处理坑位本身的相关逻辑
      path.pop()
    }
  }
}
```

<a name="upSgT"></a>

#### 动态规划

- 把问题转化为规模缩小了的同类问题的子问题
- 有明确的不需要继续进行递归的条件(base case)
- 有当得到了子问题的结果之后的决策过程
- 不记录每一个子问题的解

<a name="X1QIc"></a>

#### 例题

**爬楼梯问题**<br />每次只能爬一阶或者两阶，爬 n 阶楼梯有多少种爬法？

- 从后往前推，第 n 阶楼梯可以从 n-1、n-2 层爬上：转移方程 p[n]=p[n-1]+p[n-2]
- 最底层情况，p[1]=1；p[2]=2

```javascript
/**
 * @param {number} n
 * @return {number}
 */
const climbStairs = function (n) {
  // 初始化状态数组
  const f = [];
  // 初始化已知值
  f[1] = 1;
  f[2] = 2;
  // 动态更新每一层楼梯对应的结果
  for (let i = 3; i <= n; i++) {
    f[i] = f[i - 2] + f[i - 1];
  }
  // 返回目标值
  return f[n];
};
```

**汉诺塔问题**<br />打印 n 层汉诺塔从最左边移动到最右边的全部过程<br />尝试：<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1644913271642-63f07d0e-18a3-445d-942e-30c8a076b0c3.png##averageHue=%23f1f1f1&clientId=u223860be-745e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=632&id=u87e2af6b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1264&originWidth=1816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=477711&status=done&style=none&taskId=ub51f9cd4-9ac0-41b5-a21a-2d6aff816fb&title=&width=908)

- 设递归主函数 p(层数，出发第，目的地，其他)
- 当层数数为 i 的时候 p(i,from,to,other)，需要完全移动到 to 内部需要的步骤
  - p(i-1,from,other,to) 将 1 ～ i-1 个移动到 other 上
  - p(1,from,to,other) 将 from 剩下的一个移动到 to
  - p(i-1,other,to,from) 将 other 上的重新叠上 to
- 当 i=1 的时候为最后一个，不操作

```javascript
function hanoi(i, from, to, other) {
  if (i === 1) {
    console.log("Move 1 from" + from + "to" + to);
  } else {
    hanoi(i - 1, from, other, to);
    console.log("Move" + i + "from" + from + "to" + to);
    hanoi(i - 1, other, to, from);
  }
}
```

**全排列问题 **

```javascript
题目描述：给定一个没有重复数字的序列，返回其所有可能的全排列。
示例：
输入: [1,2,3]
输出: [
[1,2,3],
[1,3,2],
[2,1,3],
[2,3,1],
[3,1,2],
[3,2,1]
]
```

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1350314/1673252342246-983b9ed7-a8f3-4878-9b0e-d0e39cefd81a.png##averageHue=%23f6bcb6&clientId=u00f03651-1e80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=481&id=u15262d37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=962&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&size=374209&status=done&style=none&taskId=ua1eca73f-54e8-4e06-b2d6-208fba8d1d2&title=&width=600)

- 递归边界，长度等于数组长度，nth === len
- 递归条件相同元素不能重复使用，利用 map 进行记录和筛选

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const permute = function (nums) {
  // 缓存数组的长度
  const len = nums.length;
  // curr 变量用来记录当前的排列内容
  const curr = [];
  // res 用来记录所有的排列顺序
  const res = [];
  // visited 用来避免重复使用同一个数字
  const visited = {};
  // 定义 dfs 函数，入参是坑位的索引（从 0 计数）
  function dfs(nth) {
    // 若遍历到了不存在的坑位（第 len+1 个），则触碰递归边界返回
    if (nth === len) {
      // 此时前 len 个坑位已经填满，将对应的排列记录下来
      res.push(curr.slice());
      return;
    }
    // 检查手里剩下的数字有哪些
    for (let i = 0; i < len; i++) {
      // 若 nums[i] 之前没被其它坑位用过，则可以理解为“这个数字剩下了”
      if (!visited[nums[i]]) {
        // 给 nums[i] 打个“已用过”的标
        visited[nums[i]] = 1;
        // 将nums[i]推入当前排列
        curr.push(nums[i]);
        // 基于这个排列继续往下一个坑走去
        dfs(nth + 1);
        // nums[i]让出当前坑位
        curr.pop();
        // 下掉“已用过”标识
        visited[nums[i]] = 0;
      }
    }
  }
  // 从索引为 0 的坑位（也就是第一个坑位）开始 dfs
  dfs(0);
  return res;
};
```

**组合问题**

```javascript
题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。
示例: 输入: nums = [1,2,3]
输出:
[
[3],
[1],
[2],
[1,2,3],
[1,3],
[2,3],
[1,2],
[]
]
```

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1350314/1673252487736-6ba74098-4451-462e-9f71-08082e5c08ca.png##averageHue=%23faf8f8&clientId=u00f03651-1e80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=471&id=u854fe165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=942&originWidth=1300&originalType=binary&ratio=1&rotation=0&showTitle=false&size=308535&status=done&style=none&taskId=u90d1ace5-d1e6-49b0-801c-8eea576a147&title=&width=650)

- 根据条件组件树结构，分取或不取情况形成二叉树

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
// 入参是一个数组
const subsets = function (nums) {
  // 初始化结果数组
  const res = [];
  // 缓存数组长度
  const len = nums.length;
  // 初始化组合数组
  const subset = [];
  // 进入 dfs
  dfs(0);

  // 定义 dfs 函数，入参是 nums 中的数字索引
  function dfs(index) {
    // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组
    // 不取的情况
    res.push(subset.slice());
    // 从当前数字的索引开始，遍历 nums
    for (let i = index; i < len; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(nums[i]);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};
```

**回溯剪枝**

```
题目描述：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
示例: 输入: n = 4, k = 2
输出:
[
[2,4],
[3,4],
[2,3],
[1,2],
[1,3],
[1,4],
]
```

![image.png](https://cdn.nlark.com/yuque/0/2023/png/1350314/1673257758552-3bd9c798-64f9-4b3e-bc0a-4568960e5062.png##averageHue=%23f9f7f7&clientId=u00f03651-1e80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=467&id=uec288f28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=934&originWidth=1274&originalType=binary&ratio=1&rotation=0&showTitle=false&size=340976&status=done&style=none&taskId=uf2fc292c-1f24-46a2-848e-47caaa022eb&title=&width=637)

- 在递归的过程中添加剪枝操作，满足条件则剪枝不在往下进行递归

```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
const combine = function (n, k) {
  // 初始化结果数组
  const res = [];
  // 初始化组合数组
  const subset = [];
  // 进入 dfs，起始数字是1
  dfs(1);

  // 定义 dfs 函数，入参是当前遍历到的数字
  function dfs(index) {
    if (subset.length === k) {
      res.push(subset.slice());
      return;
    }
    // 从当前数字的值开始，遍历 index-n 之间的所有数字
    for (let i = index; i <= n; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(i);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};
```

规定 1 和 A 对应、2 和 B 对应、3 和 C 对应... 那么一个数字字符串比如"111"，就可以转化为"AAA"、"KA"和"AK"。 给定一个只有数字字符组成的字符串 str，返回有多少种转化结果。

- 使用从从左往右推
- 转化情况
  - 当遇到 0 的时候无法转化，此路不通
  - 当 i=1 的时候，i 和 i+1 可以合并转化成一位
  - 当 i=2、i+1<7 的时候，i 和 i+1 可以合并转化成一位
  - 其他情况 i、i+1 各自转化成一位
  - 当 i 恰好等于字符串长度的时候终止，能转化成果

```javascript
function number(str) {
  if (str.length === 0 || str === null) return 0;
  return process(0, str);
}

function process(i, str) {
  if (i === str.length) return 1;
  if (str[i] === "0") return 1;

  if (str[i] === "1") {
    let res = process(i + 1, str);
    if (i + 1 < str.length) res += process(i + 2, str);
    return res;
  }

  if (str[i] === "2") {
    let res = process(i + 1, str);
    if (i + 1 < str.length && str[i + 1] <= 6) res += process(i + 2, str);
    return res;
  }

  return process(i + 1, str);
}
```

**背包问题**<br />给定两个长度都为 N 的数组 weights 和 values，weights[i]和 values[i]分别代表 i 号物品的重量和价值。给定一个正数 bag，表示一个载重 bag 的袋子，你装的物 品不能超过这个重量。返回你能装下最多的价值是多少?

- 从第一个份开始遍历取
- 存在两种选择，一种是取物品和跳过当前物品
- 终止条件
  - 超重，说明上一步的取法不对，当前操作无法执行，返回新增的价值 0
  - 已经遍历完所有物品，返回 0

```javascript
function maxValue(weights, values, i, bag) {
  return process(weights, values, 0, 0, bag);
}

function process(weights, values, i, aleadywight, bag) {
  if (aleadywight > bag) return 0;
  if (i === weights.length) return 0;

  return Math.max(
    // 跳过i物件，价值和负重不操作
    process(weights, values, i + 1, aleadywight, bag),
    // 选择i物件，价值增加，负重增加
    values[i] + process(weights, values, i + 1, aleadywight + weight[i], bag)
  );
}
```

**最长上升子序列**

```
题目描述：给定一个无序的整数数组，找到其中最长上升子序列的长度。

示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4

解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```

- 倒推法
  - 以第 i 个结尾的最长升序数组，分两种情况；
    - 当 i<=i-1 的时候升序中断，长为 1
    - 当 i>i-1 的时候，最长长度等于 i-1 长度加一

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
// 入参是一个数字序列
const lengthOfLIS = function (nums) {
  // 缓存序列的长度
  const len = nums.length;
  // 处理边界条件
  if (!len) {
    return 0;
  }
  // 初始化数组里面每一个索引位的状态值，默认都是最短1
  const dp = new Array(len).fill(1);
  // 初始化最大上升子序列的长度为1
  let maxLen = 1;
  // 从第2个元素开始，遍历整个数组
  for (let i = 1; i < len; i++) {
    // 每遍历一个新元素，都要“回头看”，看看能不能延长原有的上升子序列
    for (let j = 0; j < i; j++) {
      // 若遇到了一个比当前元素小的值，则意味着遇到了一个可以延长的上升子序列，故更新当前元素索引位对应的状态
      if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
      }
    }
    // 及时更新上升子序列长度的最大值
    if (dp[i] > maxLen) {
      maxLen = dp[i];
    }
  }
  // 遍历完毕，最后到手的就是最大上升子序列的长度
  return maxLen;
};
```

给定一个整型数组 arr，代表数值不同的纸牌排成一条线。玩家 A 和玩家 B 依次拿走每张纸 牌，规定玩家 A 先拿，玩家 B 后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家 A 和玩家 B 都绝顶聪明。请返回最后获胜者的分数。<br />【举例】<br />arr=[1,2,100,4]。 开始时，玩家 A 只能拿走 1 或 4。如果开始时玩家 A 拿走 1，则排列变为[2,100,4]，接下来 玩家 B 可以拿走 2 或 4，然后继续轮到玩家 A... 如果开始时玩家 A 拿走 4，则排列变为[1,2,100]，接下来玩家 B 可以拿走 1 或 100，然后继 续轮到玩家 A... 玩家 A 作为绝顶聪明的人不会先拿 4，因为拿 4 之后，玩家 B 将拿走 100。所以玩家 A 会先拿 1， 让排列变为[2,100,4]，接下来玩家 B 不管怎么选，100 都会被玩家 A 拿走。玩家 A 会获胜， 分数为 101。所以返回 101。<br />arr=[1,100,2]。 开始时，玩家 A 不管拿 1 还是 2，玩家 B 作为绝顶聪明的人，都会把 100 拿走。玩家 B 会获胜， 分数为 100。所以返回 100。

- 先后手可分成两种情况
  - 先手的下一步就是后手
  - 后手的下一步就是先手
- 取值方式也分两种，左、右取值

```javascript
function wins(arr) {
  return Math.max(f(arr, 0, length), s(arr, 0, length));
}

// 先手
function f(arr, i, j) {
  // 当i===j的时候先手只剩arr[i]
  if (i === j) return arr[i];
  // 取左右取值中最大的值
  return Math.max(s(arr, i + 1, j), s(arr, i, j - 1));
}

// 后手
function s(arr, i, j) {
  // 当i===j的时候后手已经无东西可去，因为arr[i]必会被先手所取
  if (i === j) return;
  return Math.max(f(arr, i + 1, j), f(arr, i, j - 1));
}
```

<a name="tLer4"></a>

## 总结

<a name="J6nJQ"></a>

#### 数组和链表的区别

- 从逻辑结构上来看，数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费；链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。
- 从内存存储的角度看；数组从栈中分配空间（用 new 则在堆上创建），对程序员方便快速，但是自由度小；链表从堆中分配空间，自由度大但是申请管理比较麻烦。
- 从访问方式类看，数组在内存中是连续的存储，因此可以利用下标索引进行访问；链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。
  <a name="Rmkgs"></a>

#### 各类排序算法对比

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1350314/1669186105498-e973c56c-7099-4579-b30e-6ee1c793e8b4.png##averageHue=%23e4e3e2&clientId=uc50264d2-f833-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u666ccef4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=683&originalType=url&ratio=1&rotation=0&showTitle=false&size=24475&status=done&style=none&taskId=uff74e03b-1303-4e1f-8c80-ce5b555866a&title=)
<a name="NxByv"></a>

###### 时间复杂度来说

1. 平方阶(O(n2))排序 各类简单排序:直接插入、直接选择和冒泡排序；
2. 线性对数阶(O(nlog2n))排序 快速排序、堆排序和归并排序；
3. O(n1+§))排序,§是介于 0 和 1 之间的常数。 希尔排序
4. 线性阶(O(n))排序 基数排序，此外还有桶、箱排序。

**说明：**

1. 当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至 O（n）；
2. 而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为 O（n2）；
3. 原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。
   <a name="POTEu"></a>

###### 稳定性

- 稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序
- 不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序
  <a name="CuLbZ"></a>

###### 选择排序算法准则

一般而言，需要考虑的因素有以下四点：<br />设待排序元素的个数为 n.

1. 当 n 较大，则应采用时间复杂度为 O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。
2. 当 n 较大，内存空间允许，且要求稳定性：归并排序
3. 当 n 较小，可采用直接插入或直接选择排序。直接插入排序：当元素分布有序，直接插入排序将大大减少比较次数和移动记录的次数。直接选择排序 ：元素分布有序，如果不要求稳定性，选择直接选择排序
4. 一般不使用或不直接使用传统的冒泡排序。
5. 基数排序 它是一种稳定的排序算法，但有一定的局限性：
6. 关键字可分解。
7. 记录的关键字位数较少，如果密集更好
8. 如果是数字时，最好是无符号的
