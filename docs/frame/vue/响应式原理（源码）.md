# 响应式原理（源码）

<a name="ONqkQ"></a>

## 响应式对象

1、响应式对象生成过程<br />![](https://cdn.nlark.com/yuque/0/2021/jpeg/1350314/1616381887110-f351cc59-8e75-42c2-9a2d-e7e7d6c912e7.jpeg)

```bash
function observe (value, asRootData) {
		//判断value的值类型，在Observe类中，会对obj对象进行递归observe，直到value不为对象。此时需要一下条件作为终止
    if (!isObject(value) || value instanceof VNode) {
        return
    }
    var ob;
    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__;  //_ob_属性会在new Observer中赋予
    } else if (
        shouldObserve &&
        !isServerRendering() &&
        (Array.isArray(value) || isPlainObject(value)) &&
        Object.isExtensible(value) &&
        !value._isVue
    ) {
        ob = new Observer(value);
    }
    if (asRootData && ob) {
        ob.vmCount++;
    }
    return ob
}
```

```bash
var Observer = function Observer (value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);		//将value属性赋予进_ob_中，同时此属性不可枚举（在属性循环中不可获取，避免下次中的walk的属性遍历中将_ob_带入）
    if (Array.isArray(value)) {
        if (hasProto) {
            protoAugment(value, arrayMethods);
        } else {
            copyAugment(value, arrayMethods, arrayKeys);
        }
        this.observeArray(value);	//将对象的每个值重新进行observe处理
    } else {
        this.walk(value);	//对value的值进行set和get方法设置
    }
};

Observer.prototype.observeArray = function observeArray (items) {
    for (var i = 0, l = items.length; i < l; i++) {
        observe(items[i]);
    }
};

Observer.prototype.walk = function walk (obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        defineReactive(obj, keys[i]);
    }
};

function def (obj, key, val, enumerable) {
    Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
    });
}
```

```bash
  function defineReactive (
    obj,
    key,
    val,
    customSetter,
    shallow
) {
    var dep = new Dep();
		//...
    // cater for pre-defined getter/setters
    var getter = property && property.get;
    var setter = property && property.set;
    if ((!getter || setter) && arguments.length === 2) {
        val = obj[key];
    }

    var childOb = !shallow && observe(val);  //判断传入的值是否是string，若还是对象则进行递归
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
  				//...
        },
        set: function reactiveSetter (newVal) {
					//...
        }
    });
}
```

<a name="IbbEw"></a>

## 收集依赖

- 搜集依赖就是订阅数据变化的 watcher 的收集
- 目的是当响应式数据发生变化的时候，触发 setter 通知对应的订阅者处理响应的渲染变化

mountComponent()组件初始化

```bash
    function mountComponent (
        vm,
        el,
        hydrating
    ) {
				//..
        if (config.performance && mark) {
            updateComponent = function () {
								//..
                vm._update(vnode, hydrating);
								//..
            };
        } else {
            updateComponent = function () {
                vm._update(vm._render(), hydrating);
            };
        }
				//..
        new Watcher(vm, updateComponent, noop, {  //创建订阅者
            before: function before () {
                if (vm._isMounted && !vm._isDestroyed) {
                    callHook(vm, 'beforeUpdate');
                }
            }
        }, true /* isRenderWatcher */);
				//..
        return vm
    }
```

mountComponent()=>new Watcher()

```bash
export default class Watcher {
  constructor (
    vm: Component,
    expOrFn: string | Function,  //vm._update(vm._render(), hydrating);
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    //..
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
			//..
    }
    this.value = this.lazy
      ? undefined
      : this.get()  //最后调用get属性
  }

  get () {
  //来自Dep的pushTarget，目的是将此时Wachth记录在dep中，以后用dep.target获取
  pushTarget(this)
  let value
  const vm = this.vm
  try {
    value = this.getter.call(vm, vm)  //即调用vm._update(vm._render(), hydrating);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, `getter for watcher "${this.expression}"`)
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value)
    }
    popTarget()
    this.cleanupDeps()
  }
  return value
}

```

value = this.getter.call(vm, vm)=vm.\_update(vm.\_render(), hydrating);=> vnode = render.call(vm.\_renderProxy, vm.\$createElement);<br />=>defineReactive()<br />Watcher.get()方法会调用\_render(),在渲染 vnode 时候会触发数据对象的 getter 方法，此时每个数据都有一个 dep,<br />运行 dep.depend()，将当前调用的 watch 放入数据的 dep；

```bash
    function defineReactive (

    ) {
        var dep = new Dep();
        var property = Object.getOwnPropertyDescriptor(obj, key);
        if (property && property.configurable === false) {
            return
        }
        //..
        var childOb = !shallow && observe(val);
        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function reactiveGetter () {
                var value = getter ? getter.call(obj) : val;	获取对应的data数据
                if (Dep.target) {
                    dep.depend();
                    if (childOb) {
                        childOb.dep.depend();
                        if (Array.isArray(value)) {
                            dependArray(value);
                        }
                    }
                }
                return value
            },
            set: function reactiveSetter (newVal) {
							//..
            }
        });
    }
```

defineReactive()=>New dep

```bash
export default class Dep {
  static target: ?Watcher;   //此时为在get()方法中pushTarget(this)放入的watch订阅者暂时存储位置，同时也是正在渲染的节点watch
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () { //defineReactive => childOb.dep.depend();将订阅这放入订阅者列表
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }
//通过比较id是否存储过订阅者，分别使用newDepIds和depIds进行比较
//Watcher.prototype.addDep = function addDep (dep) {
//    var id = dep.id;
//    if (!this.newDepIds.has(id)) {
//        this.newDepIds.add(id);
//        this.newDeps.push(dep);
//        if (!this.depIds.has(id)) {
//            dep.addSub(this);
//        }
//    }
//};

Dep.target = null
const targetStack = []

export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  Dep.target = target
}
//Watch.get()中，完成value = this.getter.call(vm, vm)方法后=>popTarget()；
//将当前完成的子watch删除回到父target;
//pushTarget从父到子依次添加；然后再使用poptarget方法依次从子到父移除;

export function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}

Dep.target.addDep(this)= watch.addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)	//将depIDs和deps备份一次
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)	//同时放入订阅者列表中
      }
    }
  }
```

完成 value = this.getter.call(vm, vm)方法后=>popTarget()=>Watch.cleanupDeps()

```bash
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var i = this.deps.length;
    while (i--) {
        var dep = this.deps[i];
        //由于newDepIds每次执行完都是清空，所以newDepIds可以拿到每次渲染到最新订阅者数组
        //并且进行对比，观察之前到订阅者数组对比，若有减少则去除多余到订阅者；
        if (!this.newDepIds.has(dep.id)) {
            dep.removeSub(this);
        }
    }
    //将每次更新后到最新订阅者数组保存在depIds中，并且把NewDepIds进行清空，作为下次最新订阅者储存
    var tmp = this.depIds;
    this.depIds = this.newDepIds;
    this.newDepIds = tmp;
    this.newDepIds.clear();
    tmp = this.deps;
    this.deps = this.newDeps;
    this.newDeps = tmp;
    this.newDeps.length = 0;
};
```

DepIds 为一个上次订阅者数组记录器，NewDepIds 为最新一次订阅者数组的记录器，先将这次所有的 Watch 记录起来，再与就的订阅者数组对比，若上次订阅者中有相对于这次失效的次从订阅者数组中删除，最后再对最新的订阅者 Id 进行记录。

<a name="VdRDN"></a>

## 派发更新

```bash
function defineReactive (
) {
		//..
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter () {
       	//..
        },
        set: function reactiveSetter (newVal) {
            var value = getter ? getter.call(obj) : val;
            if (newVal === value || (newVal !== newVal && value !== value)) {
                return
            }
            if (process.env.NODE_ENV !== 'production' && customSetter) {
                customSetter();
            }
            if (getter && !setter) { return }
            if (setter) {
                setter.call(obj, newVal);
            } else {
                val = newVal;
            }
            //如果修改后的是对象则重新调用observe。重新监听
            childOb = !shallow && observe(newVal);
            dep.notify();
        }
    });
}
```

dep.notify();

```bash
Dep.prototype.notify = function notify () {
    var subs = this.subs.slice();
    if (process.env.NODE_ENV !== 'production' && !config.async) {
				//统一按照父子顺序进行排序
        //若父会被销毁的话则减少通过子的过程
        subs.sort(function (a, b) { return a.id - b.id; });
    }
    for (var i = 0, l = subs.length; i < l; i++) {
        subs[i].update();
    }
};
```

subs[i].update();

```bash
Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
        this.dirty = true;
    } else if (this.sync) {  //判断是渲染Watch还是用户定义的Watch
        this.run();
    } else {
        queueWatcher(this);
    }
};
```

queueWatcher(this);

```bash
function queueWatcher (watcher) {
    var id = watcher.id;
    if (has[id] == null) {	//控制每个watch只会添加一次进入队列
        has[id] = true;
        if (!flushing) {
        //新增一个队列，将所有需要更新的watch存储起来，并且保证不会重复；如当watch在两个变化值的时候都有				//调用的话，现在值进行调用一次。
            queue.push(watcher);
        } else {
            // if already flushing, splice the watcher based on its id
            // if already past its id, it will be run next immediately.
            var i = queue.length - 1;
            while (i > index && queue[i].id > watcher.id) {
                i--;
            }
            queue.splice(i + 1, 0, watcher);
        }
        // queue the flush
        if (!waiting) {
            waiting = true;

            if (process.env.NODE_ENV !== 'production' && !config.async) {
                flushSchedulerQueue();
                return
            }
            nextTick(flushSchedulerQueue);	//异步函数，并且只有执行一次
        }
    }
}
```

nextTick(flushSchedulerQueue);

```bash
function flushSchedulerQueue () {
    currentFlushTimestamp = getNow();
    flushing = true;
    var watcher, id;
		//1.组件的更新由父到子;因为父组件的创建过程是先于子的，所以 watcher 的创建也是先父后子， 执行顺序也应该保持先父后子。
    //2.用户的自定义 watcher 要优先于渲染 watcher 执行;因为用户自定义 watcher 是在渲染 watcher 之前创建的。
    //3.如果一个组件在父组件的 执行期间被销毁，那么它对应的 watcher 执行都可以被跳 过，所以父组件的 应该先执行。
    queue.sort(function (a, b) { return a.id - b.id; });
    for (index = 0; index < queue.length; index++) {
        watcher = queue[index];
        //启动beforeUpdata钩子函数
        if (watcher.before) {
            watcher.before();
        }
        id = watcher.id;
        has[id] = null;
        watcher.run();
        // in dev build, check and stop circular updates.
        //当组件中存在无限更新watch的时候
        if (process.env.NODE_ENV !== 'production' && has[id] != null) {
            circular[id] = (circular[id] || 0) + 1;
            if (circular[id] > MAX_UPDATE_COUNT) {
                warn(
                    'You may have an infinite update loop ' + (
                        watcher.user
                            ? ("in watcher with expression \"" + (watcher.expression) + "\"")
                            : "in a component render function."
                    ),
                    watcher.vm
                );
                break
            }
        }
    }
    var activatedQueue = activatedChildren.slice();
    var updatedQueue = queue.slice();

    resetSchedulerState();

    callActivatedHooks(activatedQueue);
    callUpdatedHooks(updatedQueue);

    // devtool hook
    /* istanbul ignore if */
    if (devtools && config.devtools) {
        devtools.emit('flush');
    }
}
//把这些控制流程状态的一些变量恢复到初始值，把 watcher 队列清空。
function resetSchedulerState () {
    index = queue.length = activatedChildren.length = 0;
    has = {};
    if (process.env.NODE_ENV !== 'production') {
        circular = {};
    }
    waiting = flushing = false;
}
```

watch.run()

```bash
Watcher.prototype.run = function run () {
    if (this.active) {
        var value = this.get();//调用watch的渲染_updata的方法
        if (
            value !== this.value ||
            // Deep watchers and watchers on Object/Arrays should fire even
            // when the value is the same, because the value may
            // have mutated.
            isObject(value) ||
            this.deep
        ) {
            // set new value
            var oldValue = this.value;
            this.value = value;
            if (this.user) {
                try {
                    this.cb.call(this.vm, value, oldValue);
                } catch (e) {
                    handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
                }
            } else {
                this.cb.call(this.vm, value, oldValue);
            }
        }
    }
};
```

<a name="Us45Y"></a>

## nextTick

- **js 运行机制**

由于 js 的运行机制是单线程的，所有同步任务都会放在主线程上执行；<br />但除了主线程外还有存在一个"任务列队(task queue)"，只要有异步运行结果就在"任务列表"中放置一个时间<br />一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那 些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br />任务列表中， task 分为两大类，分别是 macro task 和 micro task，并且 每个 macro task 结束后，都要清空所有的 micro task。<br />常⻅的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate;<br />常⻅的 micro task 有 MutationObsever 和 Promise.then。

- **nextTick**

```bash
var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
    pending = false;
    var copies = callbacks.slice(0);
    callbacks.length = 0;
    for (var i = 0; i < copies.length; i++) {
        copies[i]();
    }
}
//根据当前浏览器的支持程度，将异步的方法赋予tiemrFunc，支持程度依次判断
//Promise=>MutationObserver=>setImmediate=>setTimeout()用户将nextTick中的任务列表改为异步处理函数
var timerFunc;
if (typeof Promise !== 'undefined' && isNative(Promise)) {
    var p = Promise.resolve();
    timerFunc = function () {
        p.then(flushCallbacks);
        if (isIOS) { setTimeout(noop); }
    };
    isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
	  var counter = 1;
    var observer = new MutationObserver(flushCallbacks);
    var textNode = document.createTextNode(String(counter));
    observer.observe(textNode, {
        characterData: true
    });
    timerFunc = function () {
        counter = (counter + 1) % 2;
        textNode.data = String(counter);
    };
    isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
    // Fallback to setImmediate.
    // Technically it leverages the (macro) task queue,
    // but it is still a better choice than setTimeout.
    timerFunc = function () {
        setImmediate(flushCallbacks);
    };
} else {
    timerFunc = function () {
        setTimeout()用户将nextTick中的任务列表改为异步处理函数(flushCallbacks, 0);
    };
}

function nextTick (cb, ctx) {
    var _resolve;
    //将nextTick中的函数存储在callbacks的队列中
    //try和catch避免了cb的回调函数有问题而组织整个js的运行
    callbacks.push(function () {
        if (cb) {
            try {
                cb.call(ctx);
            } catch (e) {
                handleError(e, ctx, 'nextTick');
            }
        } else if (_resolve) {
            _resolve(ctx);
        }
    });
    //保证timerFunc()只执行一次
    if (!pending) {
        pending = true;
        //将flushCallbacks中保存的函数压入tiemrFunc()异步中依次进行
        timerFunc();
    }

    if (!cb && typeof Promise !== 'undefined') {
        return new Promise(function (resolve) {
            _resolve = resolve;
        })
    }
}

```

- nextTick 常用地方：

1、在 watch 调用 set 方法是，先用一个队列将要更新的 watch 先存储起来，等待主线程完成后，用 nextTick 方法异步一起全部更新，vue 中数据和 dom 渲染由于是异步的，先更新数据，再把收集到到 watch 任务列表进行回调；<br />2、nextTick 挂载在 Vue.$nextTcik中，用户使用this.$nextTick 进行调用；保证 dom 元素和绑定数据一致，避免产生数据变化而 dom 元素并没有更新。将需要获取更新后 dom 的操作放在 nextTick 中，Vue 会将此操作放在任务列队中，当 dom 更新完后在执行回调操作。

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1350314/1616381903274-7200a5db-f067-4040-a5e6-89002401baff.png##height=355&id=AQQ6f&name=image.png&originHeight=391&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=34957&status=done&style=none&title=&width=707)

![image.png](https://cdn.nlark.com/yuque/0/2021/png/1350314/1616381919912-a1fee300-fbfd-451e-83b4-15814ca899fb.png##height=440&id=EpQzX&name=image.png&originHeight=510&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=107410&status=done&style=none&title=&width=671)<br />![image.png](https://cdn.nlark.com/yuque/0/2021/png/1350314/1616381938325-f69afedc-e48f-4cf8-b017-5009e88fa68d.png##height=665&id=VnpB8&name=image.png&originHeight=752&originWidth=779&originalType=binary&ratio=1&rotation=0&showTitle=false&size=71798&status=done&style=none&title=&width=689) 第一步

<a name="OWK5p"></a>

## 检测变化的注意事项

- **对象添加属性**

```bash
var vm = new Vue({
  data:{
			a:1
      }
})
// vm.data.b 是非响应的
vm.data.b = 2
//解决方法
Vue.set(this.data,'b',2)
```

vue.set

```bash
function set (target, key, val) {
		//..
    if (Array.isArray(target) && isValidArrayIndex(key)) {
		//..
    }
    //若此属性已经是被处理成响应式的则直接返回不做处理
    if (key in target && !(key in Object.prototype)) {
        target[key] = val;
        return val
    }
    //生成observe的时候备份一份在_ob_中
    var ob = (target).__ob__;
    if (target._isVue || (ob && ob.vmCount)) {
        process.env.NODE_ENV !== 'production' && warn(
            'Avoid adding reactive properties to a Vue instance or its root $data ' +
            'at runtime - declare it upfront in the data option.'
        );
        return val
    }
    //若整个都不是响应式数据，则重新用target
    if (!ob) {
        target[key] = val;
        return val
    }
    //对于新添加的属性转化成响应式属性
    defineReactive(ob.value, key, val);
    //手动触发通知进行set更新
    ob.dep.notify();
    return val
}
```

- 数组的变化

```bash
var vm = new Vue({
  data:[1,2,3,4]
})
// vm.b 是非响应的
vm.data.[2]='abc'
vm.data.[6]='bgc'
//解决方法
Vue.set(this.data,2,'abc')
Vue.set(this.data,6,'bgc')
```

vue.set()

```bash
function set (target, key, val) {
		//..
    if (Array.isArray(target) && isValidArrayIndex(key)) {
        target.length = Math.max(target.length, key);
        target.splice(key, 1, val);
        return val
    }
		//..
}
```

由于在 Observez 中

```bash
var Observer = function Observer (value) {
    this.value = value;
    this.dep = new Dep();
    this.vmCount = 0;
    def(value, '__ob__', this);
    if (Array.isArray(value)) {
        if (hasProto) {		//判断是否存在_proto_
            protoAugment(value, arrayMethods);	//将value指向arrayMethods
        } else {
            copyAugment(value, arrayMethods, arrayKeys);
        }
        this.observeArray(value);
    } else {
        this.walk(value);
    }
};

```

```bash
var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
    'push',
    'pop',
    'shift',
    'unshift',
    'splice',
    'sort',
    'reverse'
];
//针对与一些对数组自身发生变化对api进行原数组对修改，同时最后调用ob.dep.notify()进行跟新
methodsToPatch.forEach(function (method) {
    var original = arrayProto[method];
    def(arrayMethods, method, function mutator () {
        var args = [], len = arguments.length;
        while (len--) args[len] = arguments[len];
        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
            case 'push':
            case 'unshift':
                inserted = args;
                break
            case 'splice':
                inserted = args.slice(2);
                break
        }
        if (inserted) { ob.observeArray(inserted); }
        // notify change
        ob.dep.notify();
        return result
    });
});
```

<a name="jtrFf"></a>

## 计算属性

initState=>initComputed(vm,opts.computed)

```bash
function initComputed (vm, computed) {
		//将vm._computedWatchers置为空对象
    var watchers = vm._computedWatchers = Object.create(null);
    var isSSR = isServerRendering();

    for (var key in computed) {
        var userDef = computed[key];
        //将computed属性上定义的方法作为getter方法
        var getter = typeof userDef === 'function' ? userDef : userDef.get;
        if (process.env.NODE_ENV !== 'production' && getter == null) {
            warn(
                ("Getter is missing for computed property \"" + key + "\"."),
                vm
            );
        }

        if (!isSSR) {
            // create internal watcher for the computed property.
            watchers[key] = new Watcher(
                vm,
                getter || noop,
                noop,
                computedWatcherOptions
            );
        }

        if (!(key in vm)) {
            defineComputed(vm, key, userDef);
        } else if (process.env.NODE_ENV !== 'production') {
            if (key in vm.$data) {
                warn(("The computed property \"" + key + "\" is already defined in data."), vm);
            } else if (vm.$options.props && key in vm.$options.props) {
                warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
            }
        }
    }
}
```

渲染 watch 和 computed watch 区别

```bash
var Watcher = function Watcher (
    vm,
    expOrFn,
    cb,
    options,
    isRenderWatcher
) {
    this.vm = vm;
    if (isRenderWatcher) {
        vm._watcher = this;
    }
    vm._watchers.push(this);
    // options
    if (options) {
        this.deep = !!options.deep;
        this.user = !!options.user;
        this.lazy = !!options.lazy;//computed watch :true
        this.sync = !!options.sync;
        this.before = options.before;
    } else {
        this.deep = this.user = this.lazy = this.sync = false;
    }
		..//
    this.active = true;
    this.dirty = this.lazy; //computed watch :true
    this.deps = [];
    this.newDeps = [];
    this.depIds = new _Set();
    this.newDepIds = new _Set();
    this.expression = process.env.NODE_ENV !== 'production'
        ? expOrFn.toString()
        : '';
    // parse expression for getter
    if (typeof expOrFn === 'function') {
        this.getter = expOrFn;  //渲染watch:vm._update(vm._render(), hydrating);
        												//computed wathc:计算属性的方法
    } else {
        this.getter = parsePath(expOrFn);
        if (!this.getter) {
            this.getter = noop;
            process.env.NODE_ENV !== 'production' && warn(
                "Failed watching path: \"" + expOrFn + "\" " +
                'Watcher only accepts simple dot-delimited paths. ' +
                'For full control, use a function instead.',
                vm
            );
        }
    }
    //computed不会只是触发get()进行触发vm._updata(),将watch存入dep中
    this.value = this.lazy
        ? undefined
        : this.get();
};
```

defineComputed(vm,key,userDef)

```bash
function defineComputed (
    target,
    key,
    userDef
) {
    var shouldCache = !isServerRendering();
    //利用Object.defineProperty（）给计算属性添加getter和setter
    if (typeof userDef === 'function') {
        sharedPropertyDefinition.get = shouldCache
            ? createComputedGetter(key)
            : createGetterInvoker(userDef);
        sharedPropertyDefinition.set = noop;
    } else {
        sharedPropertyDefinition.get = userDef.get
            ? shouldCache && userDef.cache !== false
                ? createComputedGetter(key)
                : createGetterInvoker(userDef.get)
            : noop;
        sharedPropertyDefinition.set = userDef.set || noop;
    }
		//...
    Object.defineProperty(target, key, sharedPropertyDefinition);
}
```

createComputedGetter()

```bash
//返回的函数作为计算属性的getter()
function createComputedGetter (key) {
    return function computedGetter () {
        var watcher = this._computedWatchers && this._computedWatchers[key];
        if (watcher) {
            if (watcher.dirty) {
                watcher.evaluate();
            }
            if (Dep.target) {
                watcher.depend();
            }
            return watcher.value
        }
    }
}
Watcher.prototype.evaluate = function evaluate () {
    this.value = this.get();
    this.dirty = false;
};
```

当 render 渲染是访问到计算属性时，会触发计算属性到 getter();<br />1、 watcher.depend();此时 Dep.target 为渲染 watcher，所以 this.dep.depend()相当于将渲染 wather 订阅了 computed watcher<br />2、watcher.evaluate();执行 this.get()此时会返回计算属性中到响应式数据，然后继续触发响应式数据 getter，最后触发 watcher.update()进行重新渲染

<a name="6tDFD"></a>

## 监听属性

initState()=>initWathc()

```bash
function initWatch (vm, watch) {
    for (var key in watch) {
        var handler = watch[key];
        //获取watch中定义等回调函数（可看出对于一个属性调监听可以是多个回调函数）
        if (Array.isArray(handler)) {
            for (var i = 0; i < handler.length; i++) {
                createWatcher(vm, key, handler[i]);
            }
        } else {
            createWatcher(vm, key, handler);
        }
    }
}
```

createWatcher(vm,key,hander)

```bash
function createWatcher (
    vm,
    expOrFn,
    handler,
    options
) {	//当回调还设定了deep、sync等属性是hander为对象此时需要另取对象hander方法；
		//所以只定义hander是回调函数时可以是匿名函数，但是如果hander是对象，则回调方法名为hander
    if (isPlainObject(handler)) {
        options = handler;
        handler = handler.handler;
    }
    //若是字符串则从vm的方法中寻找对应的函数
    if (typeof handler === 'string') {
        handler = vm[handler];
    }
    return vm.$watch(expOrFn, handler, options)
}
```

vm.\$watch(expOrFn, handler, options)

```bash
    Vue.prototype.$watch = function (
        expOrFn,
        cb,
        options
    ) {
        var vm = this;
        if (isPlainObject(cb)) {
            return createWatcher(vm, expOrFn, cb, options)
        }
        options = options || {};
        options.user = true;
        var watcher = new Watcher(vm, expOrFn, cb, options);
        若添加immediate则立即执行
        if (options.immediate) {
            try {
                cb.call(vm, watcher.value);
            } catch (error) {
                handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
            }
        }
        return function unwatchFn () {
            watcher.teardown();
        }
    };
```

new Watcher(vm, expOrFn, cb, options);

```bash
var Watcher = function Watcher (
    vm,
    expOrFn,
    cb,
    options,
    isRenderWatcher
) {
		//..
    if (options) {
        this.deep = !!options.deep;		//深度监听
        this.user = !!options.user;		//用户watch
        this.lazy = !!options.lazy;
        this.sync = !!options.sync;		//优先执行
        this.before = options.before;
    } else {
        this.deep = this.user = this.lazy = this.sync = false;
    }
 	//..
    if (typeof expOrFn === 'function') {
        this.getter = expOrFn;
    } else {
        this.getter = parsePath(expOrFn);	//expOrFn=watcher中的key
        if (!this.getter) {
            this.getter = noop;
            process.env.NODE_ENV !== 'production' && warn(
                "Failed watching path: \"" + expOrFn + "\" " +
                'Watcher only accepts simple dot-delimited paths. ' +
                'For full control, use a function instead.',
                vm
            );
        }
    }
    this.value = this.lazy
        ? undefined
        : this.get();
};

Watcher.prototype.get = function get () {
    pushTarget(this);
    var value;
    var vm = this.vm;
    try {
     		//用于触发与key相同的响应属性的getter方法，并把此时的watcher放入订阅者中
        value = this.getter.call(vm, vm);
    }
    //..
    finally {
        // "touch" every property so they are all tracked as
        // dependencies for deep watching
        if (this.deep) {
            traverse(value); //进行深度访问value中的属性
        }
        popTarget();
        this.cleanupDeps();
    }
    return value
};

function parsePath (path) {
    if (bailRE.test(path)) {
        return
    }
    var segments = path.split('.');
    //返回一个方法用于访问与key相同的挂载vm中的响应属性
    return function (obj) {
        for (var i = 0; i < segments.length; i++) {
            if (!obj) { return }
            obj = obj[segments[i]];
        }
        return obj
    }
}
```

监听属性配置

- deep watcher

在 Watchet.get()中，如果 deep 为 true；会执行 traverse(value)对监听属性进行深度遍历，把内部对属性都触发 getter（）方法，放入订阅者中;

- immediate watcher

在 vue.\$watch()中，在 New watcher 后，若 immediate 为 true 会执行 cb.call(vm, watcher.value)，运行一次 hander 回调函数

- sync watcher

```bash
Watcher.prototype.update = function update () {
    /* istanbul ignore else */
    if (this.lazy) {
        this.dirty = true;
     //此时会立即执行不会放入queueWatcher异步执行收集器中
    } else if (this.sync) {
        this.run();
    } else {
        queueWatcher(this);
    }
};
```

<a name="rgxSA"></a>

## 组件更新

组件渲染初始化<br />mountComponent()

```javascript
function mountComponent(vm, el, hydrating) {
  //..
  var updateComponent;
  /* istanbul ignore if */
  if (process.env.NODE_ENV !== "production" && config.performance && mark) {
    //..
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }
  //创建一个watecher,同时updateComponet会赋值在Watcher.getter()方式，在Wachter被调用的时候会触发Wacther.getter()即=>vm._update
  new Watcher(
    vm,
    updateComponent,
    noop,
    {
      before: function before() {
        if (vm._isMounted && !vm._isDestroyed) {
          callHook(vm, "beforeUpdate");
        }
      },
    },
    true /* isRenderWatcher */
  );
  //..
  return vm;
}
```

再次渲染响应式变化渲染时 Wacher.getter()=vm.

```javascript
Vue.prototype._update = function (vnode, hydrating) {
  var vm = this;
  var prevEl = vm.$el;
  //旧的节点，初次渲染的时候会执行vm._vnode=vnode，将初次渲染的节点备份在_vnode中
  var prevVnode = vm._vnode;
  //..
  if (!prevVnode) {
    // 初次渲染
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
  } else {
    // 再次被响应调用渲染时候
    vm.$el = vm.__patch__(prevVnode, vnode);
  }
  //..
};
```

vm._partch_

```javascript
function patch(oldVnode, vnode, hydrating, removeOnly) {
  //...
  //...响应是更新的时候oldVnode存在
  if (isUndef(oldVnode)) {
    //...
  } else {
    //判断老节点是否是dom节点
    var isRealElement = isDef(oldVnode.nodeType);
    if (!isRealElement && sameVnode(oldVnode, vnode)) {
      // 新旧节点相同当时候
      patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
    } else {
      //...
      //当新旧节点不一样当时候
      //第一步创建新节点
      var oldElm = oldVnode.elm;
      //获取旧节点的父节点方便进行新增和删除操作
      //parentElm是整真实的dom节点,vnode.parent是占位符父级节点
      var parentElm = nodeOps.parentNode(oldElm);
      createElm(
        vnode,
        insertedVnodeQueue,
        oldElm._leaveCb ? null : parentElm,
        nodeOps.nextSibling(oldElm)
      );

      //递归找到新节点的占位符父节点
      //先后执行module、destory等钩子函数
      if (isDef(vnode.parent)) {
        var ancestor = vnode.parent;
        var patchable = isPatchable(vnode);
        while (ancestor) {
          for (var i = 0; i < cbs.destroy.length; ++i) {
            cbs.destroy[i](ancestor);
          }
          ancestor.elm = vnode.elm;
          if (patchable) {
            for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
              cbs.create[i$1](emptyNode, ancestor);
            }
            var insert = ancestor.data.hook.insert;
            if (insert.merged) {
              for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                insert.fns[i$2]();
              }
            }
          } else {
            registerRef(ancestor);
          }
          ancestor = ancestor.parent;
        }
      }

      //将旧节点从dom树中删除
      if (isDef(parentElm)) {
        removeVnodes([oldVnode], 0, 0);
      } else if (isDef(oldVnode.tag)) {
        invokeDestroyHook(oldVnode);
      }
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
  return vnode.elm;
}

//判断两个节点是否相同
function sameVnode(a, b) {
  return (
    a.key === b.key && //普通节点key为undefind,主要用于for循环的key
    ((a.tag === b.tag && //标签是否相同
      a.isComment === b.isComment &&
      isDef(a.data) === isDef(b.data) &&
      sameInputType(a, b)) ||
      //当节点为异步节点当时候
      (isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)))
  );
}
```

当新旧节点相同的时候=>patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);

```javascript
function patchVnode(
  oldVnode,
  vnode,
  insertedVnodeQueue,
  ownerArray,
  index,
  removeOnly
) {
  //...用于对比新旧节点是否相同，是则返回
  //prepatch（）=>updateChildComponent()：将新的vnode对应的实例vm的一系列属性进行更新（占位符、vm.$vnode、slot、listeners等）
  var i;
  var data = vnode.data;
  if (isDef(data) && isDef((i = data.hook)) && isDef((i = i.prepatch))) {
    i(oldVnode, vnode);
  }

  var oldCh = oldVnode.children;
  var ch = vnode.children;
  if (isDef(data) && isPatchable(vnode)) {
    for (i = 0; i < cbs.update.length; ++i) {
      cbs.update[i](oldVnode, vnode);
    }
    if (isDef((i = data.hook)) && isDef((i = i.update))) {
      i(oldVnode, vnode);
    }
  }
  //当新节点不是文本节点当时候
  if (isUndef(vnode.text)) {
    //新旧子节点都存在且不相同时候，使用updateChildren()更新
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) {
        updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
      }
      //当新节点子节点存在，旧节点子节点不存在的时候
      //若旧节点存在文本节点，先将父节点下的旧节点的文本节点清除，在插入新节点
    } else if (isDef(ch)) {
      if (process.env.NODE_ENV !== "production") {
        checkDuplicateKeys(ch);
      }
      if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, "");
      }
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      //当只有旧节点的存在，新节点不存在则直接删除旧节点
    } else if (isDef(oldCh)) {
      removeVnodes(oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      nodeOps.setTextContent(elm, "");
    }
    //新旧节点都是文本本节点，且不相同，直接替换节点的文本内容
  } else if (oldVnode.text !== vnode.text) {
    nodeOps.setTextContent(elm, vnode.text);
  }
  if (isDef(data)) {
    if (isDef((i = data.hook)) && isDef((i = i.postpatch))) {
      i(oldVnode, vnode);
    }
  }
}
```

但新旧节点不相等，却都不是文本节点

```javascript
function updateChildren(
  parentElm,
  oldCh,
  newCh,
  insertedVnodeQueue,
  removeOnly
) {
  var oldStartIdx = 0;
  var newStartIdx = 0;
  var oldEndIdx = oldCh.length - 1;
  var oldStartVnode = oldCh[0];
  var oldEndVnode = oldCh[oldEndIdx];
  var newEndIdx = newCh.length - 1;
  var newStartVnode = newCh[0];
  var newEndVnode = newCh[newEndIdx];
  var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

  // removeOnly is a special flag used only by <transition-group>
  // to ensure removed elements stay in correct relative positions
  // during leaving transitions
  var canMove = !removeOnly;

  if (process.env.NODE_ENV !== "production") {
    checkDuplicateKeys(newCh);
  }
  //重点的diff算法，主要是根据oldStartIdx、oldEndIdx、newStartIdx、newEndIdx的实时情况进行变换，尽量使用节点的移动来代替节点的新增和删除
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isUndef(oldStartVnode)) {
      oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
    } else if (isUndef(oldEndVnode)) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(
        oldStartVnode,
        newStartVnode,
        insertedVnodeQueue,
        newCh,
        newStartIdx
      );
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(
        oldEndVnode,
        newEndVnode,
        insertedVnodeQueue,
        newCh,
        newEndIdx
      );
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      // Vnode moved right
      patchVnode(
        oldStartVnode,
        newEndVnode,
        insertedVnodeQueue,
        newCh,
        newEndIdx
      );
      canMove &&
        nodeOps.insertBefore(
          parentElm,
          oldStartVnode.elm,
          nodeOps.nextSibling(oldEndVnode.elm)
        );
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      // Vnode moved left
      patchVnode(
        oldEndVnode,
        newStartVnode,
        insertedVnodeQueue,
        newCh,
        newStartIdx
      );
      canMove &&
        nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
      if (isUndef(idxInOld)) {
        // New element
        createElm(
          newStartVnode,
          insertedVnodeQueue,
          parentElm,
          oldStartVnode.elm,
          false,
          newCh,
          newStartIdx
        );
      } else {
        vnodeToMove = oldCh[idxInOld];
        if (sameVnode(vnodeToMove, newStartVnode)) {
          patchVnode(
            vnodeToMove,
            newStartVnode,
            insertedVnodeQueue,
            newCh,
            newStartIdx
          );
          oldCh[idxInOld] = undefined;
          canMove &&
            nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
        } else {
          // same key but different element. treat as new element
          createElm(
            newStartVnode,
            insertedVnodeQueue,
            parentElm,
            oldStartVnode.elm,
            false,
            newCh,
            newStartIdx
          );
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }
  if (oldStartIdx > oldEndIdx) {
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
    addVnodes(
      parentElm,
      refElm,
      newCh,
      newStartIdx,
      newEndIdx,
      insertedVnodeQueue
    );
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
}
```

例子

```javascript
<template>
  <div id="app">
		<div>
    	<ul>
				<li v-for="item in items" :key="item.id">{{ item.val }}</li> </ul>
		</div>
    <button @click="change">change</button>
  </div>
</template>
<script>
  export default {
    name: 'App',
    data() {
      return {
        items: [
          {id: 0, val: 'A'},
          {id: 1, val: 'B'},
          {id: 2, val: 'C'},
          {id: 3, val: 'D'}
					]
      }
		},
    methods: {
			change() {
				this.items.reverse().push({id: 4, val: 'E'})
			}
    }
	}
</script>
//当我们点击 change 按钮去改变数据，最终会执行到 updateChildren 去更新 li 部分的列表数 据，我们通过图的方式来描述一下它的更新过程:
```

- 第一步

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1350314/1605932227654-1538c36b-bac1-457d-aa9f-107e7331886d.png##height=395&id=tHox2&name=image.png&originHeight=395&originWidth=760&originalType=binary&ratio=1&rotation=0&showTitle=false&size=138150&status=done&style=none&title=&width=760)<br />执行分支

```javascript
if (sameVnode(oldEndVnode, newStartVnode)) {
  // Vnode moved left
  //执行新旧子节点的内部替换
  patchVnode(
    oldEndVnode,
    newStartVnode,
    insertedVnodeQueue,
    newCh,
    newStartIdx
  );
  canMove &&
    nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
  oldEndVnode = oldCh[--oldEndIdx];
  newStartVnode = newCh[++newStartIdx];
}
```

- 第二步

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1350314/1605932504524-fb029c34-8c98-4c50-8da2-647a52eb18dd.png##height=457&id=pUWyo&name=image.png&originHeight=457&originWidth=769&originalType=binary&ratio=1&rotation=0&showTitle=false&size=135532&status=done&style=none&title=&width=769)<br />仍旧执行第一步分支

- 第三步

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1350314/1605932575519-2af3e4e9-c132-4fa0-985d-2f1b25feebb5.png##height=456&id=vdP5H&name=image.png&originHeight=456&originWidth=805&originalType=binary&ratio=1&rotation=0&showTitle=false&size=141005&status=done&style=none&title=&width=805)<br />执行第一步分支

- 第四部

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1350314/1605932618405-c6502902-a2ce-4343-9b14-a9899dca2e23.png##height=470&id=ONn01&name=image.png&originHeight=470&originWidth=835&originalType=binary&ratio=1&rotation=0&showTitle=false&size=151402&status=done&style=none&title=&width=835)<br />执行分支

```javascript
if (sameVnode(oldStartVnode, newStartVnode)) {
  patchVnode(
    oldStartVnode,
    newStartVnode,
    insertedVnodeQueue,
    newCh,
    newStartIdx
  );
  oldStartVnode = oldCh[++oldStartIdx];
  newStartVnode = newCh[++newStartIdx];
}
```

- 第五步

执行分支

```javascript
if (oldStartIdx > oldEndIdx) {
  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
  //将新节点剩余的子节点全部插入到后面
  addVnodes(
    parentElm,
    refElm,
    newCh,
    newStartIdx,
    newEndIdx,
    insertedVnodeQueue
  );
}
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1350314/1605933458869-a97589fd-b6e6-4e44-9d47-2e6640ad898e.png##height=500&id=lGOID&name=image.png&originHeight=500&originWidth=876&originalType=binary&ratio=1&rotation=0&showTitle=false&size=155619&status=done&style=none&title=&width=876)<br />组件更新的过程核心就是新旧 vnode diff，对新旧节点相同以及不同的情况分别做不同的处理。<br />新旧节点不同的更新流程是创建新节点->更新父占位符节点->删除旧节点;<br />而新旧节点相同的更新流程是去获 取它们的 children，根据不同情况做不同的更新逻辑。最复杂的情况是新旧节点相同且它们都存在子节点，那么会执行 updateChildren 逻辑，这块儿可以借助画图的方式配合理解。
